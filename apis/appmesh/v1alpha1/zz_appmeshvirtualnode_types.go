/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type AppmeshVirtualNodeObservation struct {
	Arn string `json:"arn" tf:"arn"`

	CreatedDate string `json:"createdDate" tf:"created_date"`

	LastUpdatedDate string `json:"lastUpdatedDate" tf:"last_updated_date"`

	ResourceOwner string `json:"resourceOwner" tf:"resource_owner"`
}

type AppmeshVirtualNodeParameters struct {

	// +kubebuilder:validation:Required
	MeshName string `json:"meshName" tf:"mesh_name"`

	// +kubebuilder:validation:Optional
	MeshOwner *string `json:"meshOwner,omitempty" tf:"mesh_owner"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region string `json:"region" tf:"-"`

	// +kubebuilder:validation:Required
	Spec []AppmeshVirtualNodeSpecParameters `json:"spec" tf:"spec"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Optional
	TagsAll map[string]string `json:"tagsAll,omitempty" tf:"tags_all"`
}

type AppmeshVirtualNodeSpecObservation struct {
}

type AppmeshVirtualNodeSpecParameters struct {

	// +kubebuilder:validation:Optional
	Backend []BackendParameters `json:"backend,omitempty" tf:"backend"`

	// +kubebuilder:validation:Optional
	BackendDefaults []SpecBackendDefaultsParameters `json:"backendDefaults,omitempty" tf:"backend_defaults"`

	// +kubebuilder:validation:Optional
	Listener []SpecListenerParameters `json:"listener,omitempty" tf:"listener"`

	// +kubebuilder:validation:Optional
	Logging []SpecLoggingParameters `json:"logging,omitempty" tf:"logging"`

	// +kubebuilder:validation:Optional
	ServiceDiscovery []ServiceDiscoveryParameters `json:"serviceDiscovery,omitempty" tf:"service_discovery"`
}

type AwsCloudMapObservation struct {
}

type AwsCloudMapParameters struct {

	// +kubebuilder:validation:Optional
	Attributes map[string]string `json:"attributes,omitempty" tf:"attributes"`

	// +kubebuilder:validation:Required
	NamespaceName string `json:"namespaceName" tf:"namespace_name"`

	// +kubebuilder:validation:Required
	ServiceName string `json:"serviceName" tf:"service_name"`
}

type BackendDefaultsClientPolicyObservation struct {
}

type BackendDefaultsClientPolicyParameters struct {

	// +kubebuilder:validation:Optional
	TLS []BackendDefaultsClientPolicyTLSParameters `json:"tls,omitempty" tf:"tls"`
}

type BackendDefaultsClientPolicyTLSCertificateObservation struct {
}

type BackendDefaultsClientPolicyTLSCertificateParameters struct {

	// +kubebuilder:validation:Optional
	File []ClientPolicyTLSCertificateFileParameters `json:"file,omitempty" tf:"file"`

	// +kubebuilder:validation:Optional
	Sds []ClientPolicyTLSCertificateSdsParameters `json:"sds,omitempty" tf:"sds"`
}

type BackendDefaultsClientPolicyTLSObservation struct {
}

type BackendDefaultsClientPolicyTLSParameters struct {

	// +kubebuilder:validation:Optional
	Certificate []BackendDefaultsClientPolicyTLSCertificateParameters `json:"certificate,omitempty" tf:"certificate"`

	// +kubebuilder:validation:Optional
	Enforce *bool `json:"enforce,omitempty" tf:"enforce"`

	// +kubebuilder:validation:Optional
	Ports []int64 `json:"ports,omitempty" tf:"ports"`

	// +kubebuilder:validation:Required
	Validation []BackendDefaultsClientPolicyTLSValidationParameters `json:"validation" tf:"validation"`
}

type BackendDefaultsClientPolicyTLSValidationObservation struct {
}

type BackendDefaultsClientPolicyTLSValidationParameters struct {

	// +kubebuilder:validation:Optional
	SubjectAlternativeNames []ClientPolicyTLSValidationSubjectAlternativeNamesParameters `json:"subjectAlternativeNames,omitempty" tf:"subject_alternative_names"`

	// +kubebuilder:validation:Required
	Trust []ClientPolicyTLSValidationTrustParameters `json:"trust" tf:"trust"`
}

type BackendObservation struct {
}

type BackendParameters struct {

	// +kubebuilder:validation:Required
	VirtualService []BackendVirtualServiceParameters `json:"virtualService" tf:"virtual_service"`
}

type BackendVirtualServiceObservation struct {
}

type BackendVirtualServiceParameters struct {

	// +kubebuilder:validation:Optional
	ClientPolicy []VirtualServiceClientPolicyParameters `json:"clientPolicy,omitempty" tf:"client_policy"`

	// +kubebuilder:validation:Required
	VirtualServiceName string `json:"virtualServiceName" tf:"virtual_service_name"`
}

type BaseEjectionDurationObservation struct {
}

type BaseEjectionDurationParameters struct {

	// +kubebuilder:validation:Required
	Unit string `json:"unit" tf:"unit"`

	// +kubebuilder:validation:Required
	Value int64 `json:"value" tf:"value"`
}

type ClientPolicyTLSCertificateFileObservation struct {
}

type ClientPolicyTLSCertificateFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain string `json:"certificateChain" tf:"certificate_chain"`

	// +kubebuilder:validation:Required
	PrivateKey string `json:"privateKey" tf:"private_key"`
}

type ClientPolicyTLSCertificateObservation struct {
}

type ClientPolicyTLSCertificateParameters struct {

	// +kubebuilder:validation:Optional
	File []TLSCertificateFileParameters `json:"file,omitempty" tf:"file"`

	// +kubebuilder:validation:Optional
	Sds []TLSCertificateSdsParameters `json:"sds,omitempty" tf:"sds"`
}

type ClientPolicyTLSCertificateSdsObservation struct {
}

type ClientPolicyTLSCertificateSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName string `json:"secretName" tf:"secret_name"`
}

type ClientPolicyTLSObservation struct {
}

type ClientPolicyTLSParameters struct {

	// +kubebuilder:validation:Optional
	Certificate []ClientPolicyTLSCertificateParameters `json:"certificate,omitempty" tf:"certificate"`

	// +kubebuilder:validation:Optional
	Enforce *bool `json:"enforce,omitempty" tf:"enforce"`

	// +kubebuilder:validation:Optional
	Ports []int64 `json:"ports,omitempty" tf:"ports"`

	// +kubebuilder:validation:Required
	Validation []ClientPolicyTLSValidationParameters `json:"validation" tf:"validation"`
}

type ClientPolicyTLSValidationObservation struct {
}

type ClientPolicyTLSValidationParameters struct {

	// +kubebuilder:validation:Optional
	SubjectAlternativeNames []TLSValidationSubjectAlternativeNamesParameters `json:"subjectAlternativeNames,omitempty" tf:"subject_alternative_names"`

	// +kubebuilder:validation:Required
	Trust []TLSValidationTrustParameters `json:"trust" tf:"trust"`
}

type ClientPolicyTLSValidationSubjectAlternativeNamesMatchObservation struct {
}

type ClientPolicyTLSValidationSubjectAlternativeNamesMatchParameters struct {

	// +kubebuilder:validation:Required
	Exact []string `json:"exact" tf:"exact"`
}

type ClientPolicyTLSValidationSubjectAlternativeNamesObservation struct {
}

type ClientPolicyTLSValidationSubjectAlternativeNamesParameters struct {

	// +kubebuilder:validation:Required
	Match []ClientPolicyTLSValidationSubjectAlternativeNamesMatchParameters `json:"match" tf:"match"`
}

type ClientPolicyTLSValidationTrustFileObservation struct {
}

type ClientPolicyTLSValidationTrustFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain string `json:"certificateChain" tf:"certificate_chain"`
}

type ClientPolicyTLSValidationTrustObservation struct {
}

type ClientPolicyTLSValidationTrustParameters struct {

	// +kubebuilder:validation:Optional
	Acm []ValidationTrustAcmParameters `json:"acm,omitempty" tf:"acm"`

	// +kubebuilder:validation:Optional
	File []ClientPolicyTLSValidationTrustFileParameters `json:"file,omitempty" tf:"file"`

	// +kubebuilder:validation:Optional
	Sds []ClientPolicyTLSValidationTrustSdsParameters `json:"sds,omitempty" tf:"sds"`
}

type ClientPolicyTLSValidationTrustSdsObservation struct {
}

type ClientPolicyTLSValidationTrustSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName string `json:"secretName" tf:"secret_name"`
}

type ConnectionPoolGrpcObservation struct {
}

type ConnectionPoolGrpcParameters struct {

	// +kubebuilder:validation:Required
	MaxRequests int64 `json:"maxRequests" tf:"max_requests"`
}

type ConnectionPoolHTTPObservation struct {
}

type ConnectionPoolHTTPParameters struct {

	// +kubebuilder:validation:Required
	MaxConnections int64 `json:"maxConnections" tf:"max_connections"`

	// +kubebuilder:validation:Optional
	MaxPendingRequests *int64 `json:"maxPendingRequests,omitempty" tf:"max_pending_requests"`
}

type ConnectionPoolHttp2Observation struct {
}

type ConnectionPoolHttp2Parameters struct {

	// +kubebuilder:validation:Required
	MaxRequests int64 `json:"maxRequests" tf:"max_requests"`
}

type DNSObservation struct {
}

type DNSParameters struct {

	// +kubebuilder:validation:Required
	Hostname string `json:"hostname" tf:"hostname"`
}

type GrpcIdleObservation struct {
}

type GrpcIdleParameters struct {

	// +kubebuilder:validation:Required
	Unit string `json:"unit" tf:"unit"`

	// +kubebuilder:validation:Required
	Value int64 `json:"value" tf:"value"`
}

type GrpcPerRequestObservation struct {
}

type GrpcPerRequestParameters struct {

	// +kubebuilder:validation:Required
	Unit string `json:"unit" tf:"unit"`

	// +kubebuilder:validation:Required
	Value int64 `json:"value" tf:"value"`
}

type HTTPIdleObservation struct {
}

type HTTPIdleParameters struct {

	// +kubebuilder:validation:Required
	Unit string `json:"unit" tf:"unit"`

	// +kubebuilder:validation:Required
	Value int64 `json:"value" tf:"value"`
}

type HTTPPerRequestObservation struct {
}

type HTTPPerRequestParameters struct {

	// +kubebuilder:validation:Required
	Unit string `json:"unit" tf:"unit"`

	// +kubebuilder:validation:Required
	Value int64 `json:"value" tf:"value"`
}

type Http2IdleObservation struct {
}

type Http2IdleParameters struct {

	// +kubebuilder:validation:Required
	Unit string `json:"unit" tf:"unit"`

	// +kubebuilder:validation:Required
	Value int64 `json:"value" tf:"value"`
}

type Http2PerRequestObservation struct {
}

type Http2PerRequestParameters struct {

	// +kubebuilder:validation:Required
	Unit string `json:"unit" tf:"unit"`

	// +kubebuilder:validation:Required
	Value int64 `json:"value" tf:"value"`
}

type IntervalObservation struct {
}

type IntervalParameters struct {

	// +kubebuilder:validation:Required
	Unit string `json:"unit" tf:"unit"`

	// +kubebuilder:validation:Required
	Value int64 `json:"value" tf:"value"`
}

type ListenerConnectionPoolObservation struct {
}

type ListenerConnectionPoolParameters struct {

	// +kubebuilder:validation:Optional
	Grpc []ConnectionPoolGrpcParameters `json:"grpc,omitempty" tf:"grpc"`

	// +kubebuilder:validation:Optional
	HTTP []ConnectionPoolHTTPParameters `json:"http,omitempty" tf:"http"`

	// +kubebuilder:validation:Optional
	Http2 []ConnectionPoolHttp2Parameters `json:"http2,omitempty" tf:"http2"`

	// +kubebuilder:validation:Optional
	TCP []TCPParameters `json:"tcp,omitempty" tf:"tcp"`
}

type ListenerHealthCheckObservation struct {
}

type ListenerHealthCheckParameters struct {

	// +kubebuilder:validation:Required
	HealthyThreshold int64 `json:"healthyThreshold" tf:"healthy_threshold"`

	// +kubebuilder:validation:Required
	IntervalMillis int64 `json:"intervalMillis" tf:"interval_millis"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path"`

	// +kubebuilder:validation:Optional
	Port *int64 `json:"port,omitempty" tf:"port"`

	// +kubebuilder:validation:Required
	Protocol string `json:"protocol" tf:"protocol"`

	// +kubebuilder:validation:Required
	TimeoutMillis int64 `json:"timeoutMillis" tf:"timeout_millis"`

	// +kubebuilder:validation:Required
	UnhealthyThreshold int64 `json:"unhealthyThreshold" tf:"unhealthy_threshold"`
}

type ListenerPortMappingObservation struct {
}

type ListenerPortMappingParameters struct {

	// +kubebuilder:validation:Required
	Port int64 `json:"port" tf:"port"`

	// +kubebuilder:validation:Required
	Protocol string `json:"protocol" tf:"protocol"`
}

type ListenerTLSCertificateFileObservation struct {
}

type ListenerTLSCertificateFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain string `json:"certificateChain" tf:"certificate_chain"`

	// +kubebuilder:validation:Required
	PrivateKey string `json:"privateKey" tf:"private_key"`
}

type ListenerTLSCertificateObservation struct {
}

type ListenerTLSCertificateParameters struct {

	// +kubebuilder:validation:Optional
	Acm []TLSCertificateAcmParameters `json:"acm,omitempty" tf:"acm"`

	// +kubebuilder:validation:Optional
	File []ListenerTLSCertificateFileParameters `json:"file,omitempty" tf:"file"`

	// +kubebuilder:validation:Optional
	Sds []ListenerTLSCertificateSdsParameters `json:"sds,omitempty" tf:"sds"`
}

type ListenerTLSCertificateSdsObservation struct {
}

type ListenerTLSCertificateSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName string `json:"secretName" tf:"secret_name"`
}

type ListenerTLSValidationObservation struct {
}

type ListenerTLSValidationParameters struct {

	// +kubebuilder:validation:Optional
	SubjectAlternativeNames []ListenerTLSValidationSubjectAlternativeNamesParameters `json:"subjectAlternativeNames,omitempty" tf:"subject_alternative_names"`

	// +kubebuilder:validation:Required
	Trust []ListenerTLSValidationTrustParameters `json:"trust" tf:"trust"`
}

type ListenerTLSValidationSubjectAlternativeNamesMatchObservation struct {
}

type ListenerTLSValidationSubjectAlternativeNamesMatchParameters struct {

	// +kubebuilder:validation:Required
	Exact []string `json:"exact" tf:"exact"`
}

type ListenerTLSValidationSubjectAlternativeNamesObservation struct {
}

type ListenerTLSValidationSubjectAlternativeNamesParameters struct {

	// +kubebuilder:validation:Required
	Match []ListenerTLSValidationSubjectAlternativeNamesMatchParameters `json:"match" tf:"match"`
}

type ListenerTLSValidationTrustFileObservation struct {
}

type ListenerTLSValidationTrustFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain string `json:"certificateChain" tf:"certificate_chain"`
}

type ListenerTLSValidationTrustObservation struct {
}

type ListenerTLSValidationTrustParameters struct {

	// +kubebuilder:validation:Optional
	File []ListenerTLSValidationTrustFileParameters `json:"file,omitempty" tf:"file"`

	// +kubebuilder:validation:Optional
	Sds []ListenerTLSValidationTrustSdsParameters `json:"sds,omitempty" tf:"sds"`
}

type ListenerTLSValidationTrustSdsObservation struct {
}

type ListenerTLSValidationTrustSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName string `json:"secretName" tf:"secret_name"`
}

type ListenerTimeoutObservation struct {
}

type ListenerTimeoutParameters struct {

	// +kubebuilder:validation:Optional
	Grpc []TimeoutGrpcParameters `json:"grpc,omitempty" tf:"grpc"`

	// +kubebuilder:validation:Optional
	HTTP []TimeoutHTTPParameters `json:"http,omitempty" tf:"http"`

	// +kubebuilder:validation:Optional
	Http2 []TimeoutHttp2Parameters `json:"http2,omitempty" tf:"http2"`

	// +kubebuilder:validation:Optional
	TCP []TimeoutTCPParameters `json:"tcp,omitempty" tf:"tcp"`
}

type LoggingAccessLogFileObservation struct {
}

type LoggingAccessLogFileParameters struct {

	// +kubebuilder:validation:Required
	Path string `json:"path" tf:"path"`
}

type LoggingAccessLogObservation struct {
}

type LoggingAccessLogParameters struct {

	// +kubebuilder:validation:Optional
	File []LoggingAccessLogFileParameters `json:"file,omitempty" tf:"file"`
}

type OutlierDetectionObservation struct {
}

type OutlierDetectionParameters struct {

	// +kubebuilder:validation:Required
	BaseEjectionDuration []BaseEjectionDurationParameters `json:"baseEjectionDuration" tf:"base_ejection_duration"`

	// +kubebuilder:validation:Required
	Interval []IntervalParameters `json:"interval" tf:"interval"`

	// +kubebuilder:validation:Required
	MaxEjectionPercent int64 `json:"maxEjectionPercent" tf:"max_ejection_percent"`

	// +kubebuilder:validation:Required
	MaxServerErrors int64 `json:"maxServerErrors" tf:"max_server_errors"`
}

type ServiceDiscoveryObservation struct {
}

type ServiceDiscoveryParameters struct {

	// +kubebuilder:validation:Optional
	AwsCloudMap []AwsCloudMapParameters `json:"awsCloudMap,omitempty" tf:"aws_cloud_map"`

	// +kubebuilder:validation:Optional
	DNS []DNSParameters `json:"dns,omitempty" tf:"dns"`
}

type SpecBackendDefaultsObservation struct {
}

type SpecBackendDefaultsParameters struct {

	// +kubebuilder:validation:Optional
	ClientPolicy []BackendDefaultsClientPolicyParameters `json:"clientPolicy,omitempty" tf:"client_policy"`
}

type SpecListenerObservation struct {
}

type SpecListenerParameters struct {

	// +kubebuilder:validation:Optional
	ConnectionPool []ListenerConnectionPoolParameters `json:"connectionPool,omitempty" tf:"connection_pool"`

	// +kubebuilder:validation:Optional
	HealthCheck []ListenerHealthCheckParameters `json:"healthCheck,omitempty" tf:"health_check"`

	// +kubebuilder:validation:Optional
	OutlierDetection []OutlierDetectionParameters `json:"outlierDetection,omitempty" tf:"outlier_detection"`

	// +kubebuilder:validation:Required
	PortMapping []ListenerPortMappingParameters `json:"portMapping" tf:"port_mapping"`

	// +kubebuilder:validation:Optional
	TLS []SpecListenerTLSParameters `json:"tls,omitempty" tf:"tls"`

	// +kubebuilder:validation:Optional
	Timeout []ListenerTimeoutParameters `json:"timeout,omitempty" tf:"timeout"`
}

type SpecListenerTLSObservation struct {
}

type SpecListenerTLSParameters struct {

	// +kubebuilder:validation:Required
	Certificate []ListenerTLSCertificateParameters `json:"certificate" tf:"certificate"`

	// +kubebuilder:validation:Required
	Mode string `json:"mode" tf:"mode"`

	// +kubebuilder:validation:Optional
	Validation []ListenerTLSValidationParameters `json:"validation,omitempty" tf:"validation"`
}

type SpecLoggingObservation struct {
}

type SpecLoggingParameters struct {

	// +kubebuilder:validation:Optional
	AccessLog []LoggingAccessLogParameters `json:"accessLog,omitempty" tf:"access_log"`
}

type TCPIdleObservation struct {
}

type TCPIdleParameters struct {

	// +kubebuilder:validation:Required
	Unit string `json:"unit" tf:"unit"`

	// +kubebuilder:validation:Required
	Value int64 `json:"value" tf:"value"`
}

type TCPObservation struct {
}

type TCPParameters struct {

	// +kubebuilder:validation:Required
	MaxConnections int64 `json:"maxConnections" tf:"max_connections"`
}

type TLSCertificateAcmObservation struct {
}

type TLSCertificateAcmParameters struct {

	// +kubebuilder:validation:Required
	CertificateArn string `json:"certificateArn" tf:"certificate_arn"`
}

type TLSCertificateFileObservation struct {
}

type TLSCertificateFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain string `json:"certificateChain" tf:"certificate_chain"`

	// +kubebuilder:validation:Required
	PrivateKey string `json:"privateKey" tf:"private_key"`
}

type TLSCertificateSdsObservation struct {
}

type TLSCertificateSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName string `json:"secretName" tf:"secret_name"`
}

type TLSValidationSubjectAlternativeNamesMatchObservation struct {
}

type TLSValidationSubjectAlternativeNamesMatchParameters struct {

	// +kubebuilder:validation:Required
	Exact []string `json:"exact" tf:"exact"`
}

type TLSValidationSubjectAlternativeNamesObservation struct {
}

type TLSValidationSubjectAlternativeNamesParameters struct {

	// +kubebuilder:validation:Required
	Match []TLSValidationSubjectAlternativeNamesMatchParameters `json:"match" tf:"match"`
}

type TLSValidationTrustFileObservation struct {
}

type TLSValidationTrustFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain string `json:"certificateChain" tf:"certificate_chain"`
}

type TLSValidationTrustObservation struct {
}

type TLSValidationTrustParameters struct {

	// +kubebuilder:validation:Optional
	Acm []TrustAcmParameters `json:"acm,omitempty" tf:"acm"`

	// +kubebuilder:validation:Optional
	File []TLSValidationTrustFileParameters `json:"file,omitempty" tf:"file"`

	// +kubebuilder:validation:Optional
	Sds []TLSValidationTrustSdsParameters `json:"sds,omitempty" tf:"sds"`
}

type TLSValidationTrustSdsObservation struct {
}

type TLSValidationTrustSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName string `json:"secretName" tf:"secret_name"`
}

type TimeoutGrpcObservation struct {
}

type TimeoutGrpcParameters struct {

	// +kubebuilder:validation:Optional
	Idle []GrpcIdleParameters `json:"idle,omitempty" tf:"idle"`

	// +kubebuilder:validation:Optional
	PerRequest []GrpcPerRequestParameters `json:"perRequest,omitempty" tf:"per_request"`
}

type TimeoutHTTPObservation struct {
}

type TimeoutHTTPParameters struct {

	// +kubebuilder:validation:Optional
	Idle []HTTPIdleParameters `json:"idle,omitempty" tf:"idle"`

	// +kubebuilder:validation:Optional
	PerRequest []HTTPPerRequestParameters `json:"perRequest,omitempty" tf:"per_request"`
}

type TimeoutHttp2Observation struct {
}

type TimeoutHttp2Parameters struct {

	// +kubebuilder:validation:Optional
	Idle []Http2IdleParameters `json:"idle,omitempty" tf:"idle"`

	// +kubebuilder:validation:Optional
	PerRequest []Http2PerRequestParameters `json:"perRequest,omitempty" tf:"per_request"`
}

type TimeoutTCPObservation struct {
}

type TimeoutTCPParameters struct {

	// +kubebuilder:validation:Optional
	Idle []TCPIdleParameters `json:"idle,omitempty" tf:"idle"`
}

type TrustAcmObservation struct {
}

type TrustAcmParameters struct {

	// +kubebuilder:validation:Required
	CertificateAuthorityArns []string `json:"certificateAuthorityArns" tf:"certificate_authority_arns"`
}

type ValidationTrustAcmObservation struct {
}

type ValidationTrustAcmParameters struct {

	// +kubebuilder:validation:Required
	CertificateAuthorityArns []string `json:"certificateAuthorityArns" tf:"certificate_authority_arns"`
}

type VirtualServiceClientPolicyObservation struct {
}

type VirtualServiceClientPolicyParameters struct {

	// +kubebuilder:validation:Optional
	TLS []ClientPolicyTLSParameters `json:"tls,omitempty" tf:"tls"`
}

// AppmeshVirtualNodeSpec defines the desired state of AppmeshVirtualNode
type AppmeshVirtualNodeSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       AppmeshVirtualNodeParameters `json:"forProvider"`
}

// AppmeshVirtualNodeStatus defines the observed state of AppmeshVirtualNode.
type AppmeshVirtualNodeStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          AppmeshVirtualNodeObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// AppmeshVirtualNode is the Schema for the AppmeshVirtualNodes API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type AppmeshVirtualNode struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AppmeshVirtualNodeSpec   `json:"spec"`
	Status            AppmeshVirtualNodeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AppmeshVirtualNodeList contains a list of AppmeshVirtualNodes
type AppmeshVirtualNodeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AppmeshVirtualNode `json:"items"`
}

// Repository type metadata.
var (
	AppmeshVirtualNodeKind             = "AppmeshVirtualNode"
	AppmeshVirtualNodeGroupKind        = schema.GroupKind{Group: Group, Kind: AppmeshVirtualNodeKind}.String()
	AppmeshVirtualNodeKindAPIVersion   = AppmeshVirtualNodeKind + "." + GroupVersion.String()
	AppmeshVirtualNodeGroupVersionKind = GroupVersion.WithKind(AppmeshVirtualNodeKind)
)

func init() {
	SchemeBuilder.Register(&AppmeshVirtualNode{}, &AppmeshVirtualNodeList{})
}
