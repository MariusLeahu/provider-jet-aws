/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type AccessLogFileObservation struct {
}

type AccessLogFileParameters struct {

	// +kubebuilder:validation:Required
	Path string `json:"path" tf:"path"`
}

type AccessLogObservation struct {
}

type AccessLogParameters struct {

	// +kubebuilder:validation:Optional
	File []AccessLogFileParameters `json:"file,omitempty" tf:"file"`
}

type AcmObservation struct {
}

type AcmParameters struct {

	// +kubebuilder:validation:Required
	CertificateAuthorityArns []string `json:"certificateAuthorityArns" tf:"certificate_authority_arns"`
}

type AppmeshVirtualGatewayObservation struct {
	Arn string `json:"arn" tf:"arn"`

	CreatedDate string `json:"createdDate" tf:"created_date"`

	LastUpdatedDate string `json:"lastUpdatedDate" tf:"last_updated_date"`

	ResourceOwner string `json:"resourceOwner" tf:"resource_owner"`
}

type AppmeshVirtualGatewayParameters struct {

	// +kubebuilder:validation:Required
	MeshName string `json:"meshName" tf:"mesh_name"`

	// +kubebuilder:validation:Optional
	MeshOwner *string `json:"meshOwner,omitempty" tf:"mesh_owner"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region string `json:"region" tf:"-"`

	// +kubebuilder:validation:Required
	Spec []AppmeshVirtualGatewaySpecParameters `json:"spec" tf:"spec"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Optional
	TagsAll map[string]string `json:"tagsAll,omitempty" tf:"tags_all"`
}

type AppmeshVirtualGatewaySpecObservation struct {
}

type AppmeshVirtualGatewaySpecParameters struct {

	// +kubebuilder:validation:Optional
	BackendDefaults []BackendDefaultsParameters `json:"backendDefaults,omitempty" tf:"backend_defaults"`

	// +kubebuilder:validation:Required
	Listener []ListenerParameters `json:"listener" tf:"listener"`

	// +kubebuilder:validation:Optional
	Logging []LoggingParameters `json:"logging,omitempty" tf:"logging"`
}

type BackendDefaultsObservation struct {
}

type BackendDefaultsParameters struct {

	// +kubebuilder:validation:Optional
	ClientPolicy []ClientPolicyParameters `json:"clientPolicy,omitempty" tf:"client_policy"`
}

type CertificateAcmObservation struct {
}

type CertificateAcmParameters struct {

	// +kubebuilder:validation:Required
	CertificateArn string `json:"certificateArn" tf:"certificate_arn"`
}

type CertificateFileObservation struct {
}

type CertificateFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain string `json:"certificateChain" tf:"certificate_chain"`

	// +kubebuilder:validation:Required
	PrivateKey string `json:"privateKey" tf:"private_key"`
}

type CertificateObservation struct {
}

type CertificateParameters struct {

	// +kubebuilder:validation:Optional
	File []FileParameters `json:"file,omitempty" tf:"file"`

	// +kubebuilder:validation:Optional
	Sds []SdsParameters `json:"sds,omitempty" tf:"sds"`
}

type CertificateSdsObservation struct {
}

type CertificateSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName string `json:"secretName" tf:"secret_name"`
}

type ClientPolicyObservation struct {
}

type ClientPolicyParameters struct {

	// +kubebuilder:validation:Optional
	TLS []TLSParameters `json:"tls,omitempty" tf:"tls"`
}

type ConnectionPoolObservation struct {
}

type ConnectionPoolParameters struct {

	// +kubebuilder:validation:Optional
	Grpc []GrpcParameters `json:"grpc,omitempty" tf:"grpc"`

	// +kubebuilder:validation:Optional
	HTTP []HTTPParameters `json:"http,omitempty" tf:"http"`

	// +kubebuilder:validation:Optional
	Http2 []Http2Parameters `json:"http2,omitempty" tf:"http2"`
}

type FileObservation struct {
}

type FileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain string `json:"certificateChain" tf:"certificate_chain"`

	// +kubebuilder:validation:Required
	PrivateKey string `json:"privateKey" tf:"private_key"`
}

type GrpcObservation struct {
}

type GrpcParameters struct {

	// +kubebuilder:validation:Required
	MaxRequests int64 `json:"maxRequests" tf:"max_requests"`
}

type HTTPObservation struct {
}

type HTTPParameters struct {

	// +kubebuilder:validation:Required
	MaxConnections int64 `json:"maxConnections" tf:"max_connections"`

	// +kubebuilder:validation:Optional
	MaxPendingRequests *int64 `json:"maxPendingRequests,omitempty" tf:"max_pending_requests"`
}

type HealthCheckObservation struct {
}

type HealthCheckParameters struct {

	// +kubebuilder:validation:Required
	HealthyThreshold int64 `json:"healthyThreshold" tf:"healthy_threshold"`

	// +kubebuilder:validation:Required
	IntervalMillis int64 `json:"intervalMillis" tf:"interval_millis"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path"`

	// +kubebuilder:validation:Optional
	Port *int64 `json:"port,omitempty" tf:"port"`

	// +kubebuilder:validation:Required
	Protocol string `json:"protocol" tf:"protocol"`

	// +kubebuilder:validation:Required
	TimeoutMillis int64 `json:"timeoutMillis" tf:"timeout_millis"`

	// +kubebuilder:validation:Required
	UnhealthyThreshold int64 `json:"unhealthyThreshold" tf:"unhealthy_threshold"`
}

type Http2Observation struct {
}

type Http2Parameters struct {

	// +kubebuilder:validation:Required
	MaxRequests int64 `json:"maxRequests" tf:"max_requests"`
}

type ListenerObservation struct {
}

type ListenerParameters struct {

	// +kubebuilder:validation:Optional
	ConnectionPool []ConnectionPoolParameters `json:"connectionPool,omitempty" tf:"connection_pool"`

	// +kubebuilder:validation:Optional
	HealthCheck []HealthCheckParameters `json:"healthCheck,omitempty" tf:"health_check"`

	// +kubebuilder:validation:Required
	PortMapping []PortMappingParameters `json:"portMapping" tf:"port_mapping"`

	// +kubebuilder:validation:Optional
	TLS []ListenerTLSParameters `json:"tls,omitempty" tf:"tls"`
}

type ListenerTLSObservation struct {
}

type ListenerTLSParameters struct {

	// +kubebuilder:validation:Required
	Certificate []TLSCertificateParameters `json:"certificate" tf:"certificate"`

	// +kubebuilder:validation:Required
	Mode string `json:"mode" tf:"mode"`

	// +kubebuilder:validation:Optional
	Validation []TLSValidationParameters `json:"validation,omitempty" tf:"validation"`
}

type LoggingObservation struct {
}

type LoggingParameters struct {

	// +kubebuilder:validation:Optional
	AccessLog []AccessLogParameters `json:"accessLog,omitempty" tf:"access_log"`
}

type PortMappingObservation struct {
}

type PortMappingParameters struct {

	// +kubebuilder:validation:Required
	Port int64 `json:"port" tf:"port"`

	// +kubebuilder:validation:Required
	Protocol string `json:"protocol" tf:"protocol"`
}

type SdsObservation struct {
}

type SdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName string `json:"secretName" tf:"secret_name"`
}

type SubjectAlternativeNamesMatchObservation struct {
}

type SubjectAlternativeNamesMatchParameters struct {

	// +kubebuilder:validation:Required
	Exact []string `json:"exact" tf:"exact"`
}

type SubjectAlternativeNamesObservation struct {
}

type SubjectAlternativeNamesParameters struct {

	// +kubebuilder:validation:Required
	Match []SubjectAlternativeNamesMatchParameters `json:"match" tf:"match"`
}

type TLSCertificateObservation struct {
}

type TLSCertificateParameters struct {

	// +kubebuilder:validation:Optional
	Acm []CertificateAcmParameters `json:"acm,omitempty" tf:"acm"`

	// +kubebuilder:validation:Optional
	File []CertificateFileParameters `json:"file,omitempty" tf:"file"`

	// +kubebuilder:validation:Optional
	Sds []CertificateSdsParameters `json:"sds,omitempty" tf:"sds"`
}

type TLSObservation struct {
}

type TLSParameters struct {

	// +kubebuilder:validation:Optional
	Certificate []CertificateParameters `json:"certificate,omitempty" tf:"certificate"`

	// +kubebuilder:validation:Optional
	Enforce *bool `json:"enforce,omitempty" tf:"enforce"`

	// +kubebuilder:validation:Optional
	Ports []int64 `json:"ports,omitempty" tf:"ports"`

	// +kubebuilder:validation:Required
	Validation []ValidationParameters `json:"validation" tf:"validation"`
}

type TLSValidationObservation struct {
}

type TLSValidationParameters struct {

	// +kubebuilder:validation:Optional
	SubjectAlternativeNames []ValidationSubjectAlternativeNamesParameters `json:"subjectAlternativeNames,omitempty" tf:"subject_alternative_names"`

	// +kubebuilder:validation:Required
	Trust []ValidationTrustParameters `json:"trust" tf:"trust"`
}

type TrustFileObservation struct {
}

type TrustFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain string `json:"certificateChain" tf:"certificate_chain"`
}

type TrustObservation struct {
}

type TrustParameters struct {

	// +kubebuilder:validation:Optional
	Acm []AcmParameters `json:"acm,omitempty" tf:"acm"`

	// +kubebuilder:validation:Optional
	File []TrustFileParameters `json:"file,omitempty" tf:"file"`

	// +kubebuilder:validation:Optional
	Sds []TrustSdsParameters `json:"sds,omitempty" tf:"sds"`
}

type TrustSdsObservation struct {
}

type TrustSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName string `json:"secretName" tf:"secret_name"`
}

type ValidationObservation struct {
}

type ValidationParameters struct {

	// +kubebuilder:validation:Optional
	SubjectAlternativeNames []SubjectAlternativeNamesParameters `json:"subjectAlternativeNames,omitempty" tf:"subject_alternative_names"`

	// +kubebuilder:validation:Required
	Trust []TrustParameters `json:"trust" tf:"trust"`
}

type ValidationSubjectAlternativeNamesMatchObservation struct {
}

type ValidationSubjectAlternativeNamesMatchParameters struct {

	// +kubebuilder:validation:Required
	Exact []string `json:"exact" tf:"exact"`
}

type ValidationSubjectAlternativeNamesObservation struct {
}

type ValidationSubjectAlternativeNamesParameters struct {

	// +kubebuilder:validation:Required
	Match []ValidationSubjectAlternativeNamesMatchParameters `json:"match" tf:"match"`
}

type ValidationTrustFileObservation struct {
}

type ValidationTrustFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain string `json:"certificateChain" tf:"certificate_chain"`
}

type ValidationTrustObservation struct {
}

type ValidationTrustParameters struct {

	// +kubebuilder:validation:Optional
	File []ValidationTrustFileParameters `json:"file,omitempty" tf:"file"`

	// +kubebuilder:validation:Optional
	Sds []ValidationTrustSdsParameters `json:"sds,omitempty" tf:"sds"`
}

type ValidationTrustSdsObservation struct {
}

type ValidationTrustSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName string `json:"secretName" tf:"secret_name"`
}

// AppmeshVirtualGatewaySpec defines the desired state of AppmeshVirtualGateway
type AppmeshVirtualGatewaySpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       AppmeshVirtualGatewayParameters `json:"forProvider"`
}

// AppmeshVirtualGatewayStatus defines the observed state of AppmeshVirtualGateway.
type AppmeshVirtualGatewayStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          AppmeshVirtualGatewayObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// AppmeshVirtualGateway is the Schema for the AppmeshVirtualGateways API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type AppmeshVirtualGateway struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AppmeshVirtualGatewaySpec   `json:"spec"`
	Status            AppmeshVirtualGatewayStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AppmeshVirtualGatewayList contains a list of AppmeshVirtualGateways
type AppmeshVirtualGatewayList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AppmeshVirtualGateway `json:"items"`
}

// Repository type metadata.
var (
	AppmeshVirtualGatewayKind             = "AppmeshVirtualGateway"
	AppmeshVirtualGatewayGroupKind        = schema.GroupKind{Group: Group, Kind: AppmeshVirtualGatewayKind}.String()
	AppmeshVirtualGatewayKindAPIVersion   = AppmeshVirtualGatewayKind + "." + GroupVersion.String()
	AppmeshVirtualGatewayGroupVersionKind = GroupVersion.WithKind(AppmeshVirtualGatewayKind)
)

func init() {
	SchemeBuilder.Register(&AppmeshVirtualGateway{}, &AppmeshVirtualGatewayList{})
}
