/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type AccessControlTranslationObservation struct {
}

type AccessControlTranslationParameters struct {

	// +kubebuilder:validation:Required
	Owner string `json:"owner" tf:"owner"`
}

type ApplyServerSideEncryptionByDefaultObservation struct {
}

type ApplyServerSideEncryptionByDefaultParameters struct {

	// +kubebuilder:validation:Optional
	KmsMasterKeyID *string `json:"kmsMasterKeyId,omitempty" tf:"kms_master_key_id"`

	// +kubebuilder:validation:Required
	SseAlgorithm string `json:"sseAlgorithm" tf:"sse_algorithm"`
}

type CorsRuleObservation struct {
}

type CorsRuleParameters struct {

	// +kubebuilder:validation:Optional
	AllowedHeaders []string `json:"allowedHeaders,omitempty" tf:"allowed_headers"`

	// +kubebuilder:validation:Required
	AllowedMethods []string `json:"allowedMethods" tf:"allowed_methods"`

	// +kubebuilder:validation:Required
	AllowedOrigins []string `json:"allowedOrigins" tf:"allowed_origins"`

	// +kubebuilder:validation:Optional
	ExposeHeaders []string `json:"exposeHeaders,omitempty" tf:"expose_headers"`

	// +kubebuilder:validation:Optional
	MaxAgeSeconds *int64 `json:"maxAgeSeconds,omitempty" tf:"max_age_seconds"`
}

type DefaultRetentionObservation struct {
}

type DefaultRetentionParameters struct {

	// +kubebuilder:validation:Optional
	Days *int64 `json:"days,omitempty" tf:"days"`

	// +kubebuilder:validation:Required
	Mode string `json:"mode" tf:"mode"`

	// +kubebuilder:validation:Optional
	Years *int64 `json:"years,omitempty" tf:"years"`
}

type DestinationObservation struct {
}

type DestinationParameters struct {

	// +kubebuilder:validation:Optional
	AccessControlTranslation []AccessControlTranslationParameters `json:"accessControlTranslation,omitempty" tf:"access_control_translation"`

	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id"`

	// +kubebuilder:validation:Required
	Bucket string `json:"bucket" tf:"bucket"`

	// +kubebuilder:validation:Optional
	ReplicaKmsKeyID *string `json:"replicaKmsKeyId,omitempty" tf:"replica_kms_key_id"`

	// +kubebuilder:validation:Optional
	StorageClass *string `json:"storageClass,omitempty" tf:"storage_class"`
}

type ExpirationObservation struct {
}

type ExpirationParameters struct {

	// +kubebuilder:validation:Optional
	Date *string `json:"date,omitempty" tf:"date"`

	// +kubebuilder:validation:Optional
	Days *int64 `json:"days,omitempty" tf:"days"`

	// +kubebuilder:validation:Optional
	ExpiredObjectDeleteMarker *bool `json:"expiredObjectDeleteMarker,omitempty" tf:"expired_object_delete_marker"`
}

type FilterObservation struct {
}

type FilterParameters struct {

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`
}

type GrantObservation struct {
}

type GrantParameters struct {

	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id"`

	// +kubebuilder:validation:Required
	Permissions []string `json:"permissions" tf:"permissions"`

	// +kubebuilder:validation:Required
	Type string `json:"type" tf:"type"`

	// +kubebuilder:validation:Optional
	URI *string `json:"uri,omitempty" tf:"uri"`
}

type LifecycleRuleObservation struct {
}

type LifecycleRuleParameters struct {

	// +kubebuilder:validation:Optional
	AbortIncompleteMultipartUploadDays *int64 `json:"abortIncompleteMultipartUploadDays,omitempty" tf:"abort_incomplete_multipart_upload_days"`

	// +kubebuilder:validation:Required
	Enabled bool `json:"enabled" tf:"enabled"`

	// +kubebuilder:validation:Optional
	Expiration []ExpirationParameters `json:"expiration,omitempty" tf:"expiration"`

	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id"`

	// +kubebuilder:validation:Optional
	NoncurrentVersionExpiration []NoncurrentVersionExpirationParameters `json:"noncurrentVersionExpiration,omitempty" tf:"noncurrent_version_expiration"`

	// +kubebuilder:validation:Optional
	NoncurrentVersionTransition []NoncurrentVersionTransitionParameters `json:"noncurrentVersionTransition,omitempty" tf:"noncurrent_version_transition"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Optional
	Transition []TransitionParameters `json:"transition,omitempty" tf:"transition"`
}

type LoggingObservation struct {
}

type LoggingParameters struct {

	// +kubebuilder:validation:Required
	TargetBucket string `json:"targetBucket" tf:"target_bucket"`

	// +kubebuilder:validation:Optional
	TargetPrefix *string `json:"targetPrefix,omitempty" tf:"target_prefix"`
}

type NoncurrentVersionExpirationObservation struct {
}

type NoncurrentVersionExpirationParameters struct {

	// +kubebuilder:validation:Optional
	Days *int64 `json:"days,omitempty" tf:"days"`
}

type NoncurrentVersionTransitionObservation struct {
}

type NoncurrentVersionTransitionParameters struct {

	// +kubebuilder:validation:Optional
	Days *int64 `json:"days,omitempty" tf:"days"`

	// +kubebuilder:validation:Required
	StorageClass string `json:"storageClass" tf:"storage_class"`
}

type ObjectLockConfigurationObservation struct {
}

type ObjectLockConfigurationParameters struct {

	// +kubebuilder:validation:Required
	ObjectLockEnabled string `json:"objectLockEnabled" tf:"object_lock_enabled"`

	// +kubebuilder:validation:Optional
	Rule []RuleParameters `json:"rule,omitempty" tf:"rule"`
}

type ReplicationConfigurationObservation struct {
}

type ReplicationConfigurationParameters struct {

	// +kubebuilder:validation:Required
	Role string `json:"role" tf:"role"`

	// +kubebuilder:validation:Required
	Rules []RulesParameters `json:"rules" tf:"rules"`
}

type RuleObservation struct {
}

type RuleParameters struct {

	// +kubebuilder:validation:Required
	DefaultRetention []DefaultRetentionParameters `json:"defaultRetention" tf:"default_retention"`
}

type RulesObservation struct {
}

type RulesParameters struct {

	// +kubebuilder:validation:Optional
	DeleteMarkerReplicationStatus *string `json:"deleteMarkerReplicationStatus,omitempty" tf:"delete_marker_replication_status"`

	// +kubebuilder:validation:Required
	Destination []DestinationParameters `json:"destination" tf:"destination"`

	// +kubebuilder:validation:Optional
	Filter []FilterParameters `json:"filter,omitempty" tf:"filter"`

	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix"`

	// +kubebuilder:validation:Optional
	Priority *int64 `json:"priority,omitempty" tf:"priority"`

	// +kubebuilder:validation:Optional
	SourceSelectionCriteria []SourceSelectionCriteriaParameters `json:"sourceSelectionCriteria,omitempty" tf:"source_selection_criteria"`

	// +kubebuilder:validation:Required
	Status string `json:"status" tf:"status"`
}

type S3BucketObservation struct {
	BucketDomainName string `json:"bucketDomainName" tf:"bucket_domain_name"`

	BucketRegionalDomainName string `json:"bucketRegionalDomainName" tf:"bucket_regional_domain_name"`
}

type S3BucketParameters struct {

	// +kubebuilder:validation:Optional
	ACL *string `json:"acl,omitempty" tf:"acl"`

	// +kubebuilder:validation:Optional
	AccelerationStatus *string `json:"accelerationStatus,omitempty" tf:"acceleration_status"`

	// +kubebuilder:validation:Optional
	Arn *string `json:"arn,omitempty" tf:"arn"`

	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket,omitempty" tf:"bucket"`

	// +kubebuilder:validation:Optional
	BucketPrefix *string `json:"bucketPrefix,omitempty" tf:"bucket_prefix"`

	// +kubebuilder:validation:Optional
	CorsRule []CorsRuleParameters `json:"corsRule,omitempty" tf:"cors_rule"`

	// +kubebuilder:validation:Optional
	ForceDestroy *bool `json:"forceDestroy,omitempty" tf:"force_destroy"`

	// +kubebuilder:validation:Optional
	Grant []GrantParameters `json:"grant,omitempty" tf:"grant"`

	// +kubebuilder:validation:Optional
	HostedZoneID *string `json:"hostedZoneId,omitempty" tf:"hosted_zone_id"`

	// +kubebuilder:validation:Optional
	LifecycleRule []LifecycleRuleParameters `json:"lifecycleRule,omitempty" tf:"lifecycle_rule"`

	// +kubebuilder:validation:Optional
	Logging []LoggingParameters `json:"logging,omitempty" tf:"logging"`

	// +kubebuilder:validation:Optional
	ObjectLockConfiguration []ObjectLockConfigurationParameters `json:"objectLockConfiguration,omitempty" tf:"object_lock_configuration"`

	// +kubebuilder:validation:Optional
	Policy *string `json:"policy,omitempty" tf:"policy"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	ReplicationConfiguration []ReplicationConfigurationParameters `json:"replicationConfiguration,omitempty" tf:"replication_configuration"`

	// +kubebuilder:validation:Optional
	RequestPayer *string `json:"requestPayer,omitempty" tf:"request_payer"`

	// +kubebuilder:validation:Optional
	ServerSideEncryptionConfiguration []ServerSideEncryptionConfigurationParameters `json:"serverSideEncryptionConfiguration,omitempty" tf:"server_side_encryption_configuration"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Optional
	TagsAll map[string]string `json:"tagsAll,omitempty" tf:"tags_all"`

	// +kubebuilder:validation:Optional
	Versioning []VersioningParameters `json:"versioning,omitempty" tf:"versioning"`

	// +kubebuilder:validation:Optional
	Website []WebsiteParameters `json:"website,omitempty" tf:"website"`

	// +kubebuilder:validation:Optional
	WebsiteDomain *string `json:"websiteDomain,omitempty" tf:"website_domain"`

	// +kubebuilder:validation:Optional
	WebsiteEndpoint *string `json:"websiteEndpoint,omitempty" tf:"website_endpoint"`
}

type ServerSideEncryptionConfigurationObservation struct {
}

type ServerSideEncryptionConfigurationParameters struct {

	// +kubebuilder:validation:Required
	Rule []ServerSideEncryptionConfigurationRuleParameters `json:"rule" tf:"rule"`
}

type ServerSideEncryptionConfigurationRuleObservation struct {
}

type ServerSideEncryptionConfigurationRuleParameters struct {

	// +kubebuilder:validation:Required
	ApplyServerSideEncryptionByDefault []ApplyServerSideEncryptionByDefaultParameters `json:"applyServerSideEncryptionByDefault" tf:"apply_server_side_encryption_by_default"`

	// +kubebuilder:validation:Optional
	BucketKeyEnabled *bool `json:"bucketKeyEnabled,omitempty" tf:"bucket_key_enabled"`
}

type SourceSelectionCriteriaObservation struct {
}

type SourceSelectionCriteriaParameters struct {

	// +kubebuilder:validation:Optional
	SseKmsEncryptedObjects []SseKmsEncryptedObjectsParameters `json:"sseKmsEncryptedObjects,omitempty" tf:"sse_kms_encrypted_objects"`
}

type SseKmsEncryptedObjectsObservation struct {
}

type SseKmsEncryptedObjectsParameters struct {

	// +kubebuilder:validation:Required
	Enabled bool `json:"enabled" tf:"enabled"`
}

type TransitionObservation struct {
}

type TransitionParameters struct {

	// +kubebuilder:validation:Optional
	Date *string `json:"date,omitempty" tf:"date"`

	// +kubebuilder:validation:Optional
	Days *int64 `json:"days,omitempty" tf:"days"`

	// +kubebuilder:validation:Required
	StorageClass string `json:"storageClass" tf:"storage_class"`
}

type VersioningObservation struct {
}

type VersioningParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`

	// +kubebuilder:validation:Optional
	MfaDelete *bool `json:"mfaDelete,omitempty" tf:"mfa_delete"`
}

type WebsiteObservation struct {
}

type WebsiteParameters struct {

	// +kubebuilder:validation:Optional
	ErrorDocument *string `json:"errorDocument,omitempty" tf:"error_document"`

	// +kubebuilder:validation:Optional
	IndexDocument *string `json:"indexDocument,omitempty" tf:"index_document"`

	// +kubebuilder:validation:Optional
	RedirectAllRequestsTo *string `json:"redirectAllRequestsTo,omitempty" tf:"redirect_all_requests_to"`

	// +kubebuilder:validation:Optional
	RoutingRules *string `json:"routingRules,omitempty" tf:"routing_rules"`
}

// S3BucketSpec defines the desired state of S3Bucket
type S3BucketSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       S3BucketParameters `json:"forProvider"`
}

// S3BucketStatus defines the observed state of S3Bucket.
type S3BucketStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          S3BucketObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// S3Bucket is the Schema for the S3Buckets API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type S3Bucket struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              S3BucketSpec   `json:"spec"`
	Status            S3BucketStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// S3BucketList contains a list of S3Buckets
type S3BucketList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []S3Bucket `json:"items"`
}

// Repository type metadata.
var (
	S3BucketKind             = "S3Bucket"
	S3BucketGroupKind        = schema.GroupKind{Group: Group, Kind: S3BucketKind}.String()
	S3BucketKindAPIVersion   = S3BucketKind + "." + GroupVersion.String()
	S3BucketGroupVersionKind = GroupVersion.WithKind(S3BucketKind)
)

func init() {
	SchemeBuilder.Register(&S3Bucket{}, &S3BucketList{})
}
