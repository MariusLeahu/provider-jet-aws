/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type AuthorizationConfigObservation struct {
}

type AuthorizationConfigParameters struct {

	// +kubebuilder:validation:Optional
	AccessPointID *string `json:"accessPointId,omitempty" tf:"access_point_id"`

	// +kubebuilder:validation:Optional
	Iam *string `json:"iam,omitempty" tf:"iam"`
}

type DockerVolumeConfigurationObservation struct {
}

type DockerVolumeConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	Autoprovision *bool `json:"autoprovision,omitempty" tf:"autoprovision"`

	// +kubebuilder:validation:Optional
	Driver *string `json:"driver,omitempty" tf:"driver"`

	// +kubebuilder:validation:Optional
	DriverOpts map[string]string `json:"driverOpts,omitempty" tf:"driver_opts"`

	// +kubebuilder:validation:Optional
	Labels map[string]string `json:"labels,omitempty" tf:"labels"`

	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope"`
}

type EcsTaskDefinitionObservation struct {
	Arn string `json:"arn" tf:"arn"`

	Revision int64 `json:"revision" tf:"revision"`
}

type EcsTaskDefinitionParameters struct {

	// +kubebuilder:validation:Optional
	CPU *string `json:"cpu,omitempty" tf:"cpu"`

	// +kubebuilder:validation:Required
	ContainerDefinitions string `json:"containerDefinitions" tf:"container_definitions"`

	// +kubebuilder:validation:Optional
	EphemeralStorage []EphemeralStorageParameters `json:"ephemeralStorage,omitempty" tf:"ephemeral_storage"`

	// +kubebuilder:validation:Optional
	ExecutionRoleArn *string `json:"executionRoleArn,omitempty" tf:"execution_role_arn"`

	// +kubebuilder:validation:Required
	Family string `json:"family" tf:"family"`

	// +kubebuilder:validation:Optional
	InferenceAccelerator []InferenceAcceleratorParameters `json:"inferenceAccelerator,omitempty" tf:"inference_accelerator"`

	// +kubebuilder:validation:Optional
	IpcMode *string `json:"ipcMode,omitempty" tf:"ipc_mode"`

	// +kubebuilder:validation:Optional
	Memory *string `json:"memory,omitempty" tf:"memory"`

	// +kubebuilder:validation:Optional
	NetworkMode *string `json:"networkMode,omitempty" tf:"network_mode"`

	// +kubebuilder:validation:Optional
	PidMode *string `json:"pidMode,omitempty" tf:"pid_mode"`

	// +kubebuilder:validation:Optional
	PlacementConstraints []EcsTaskDefinitionPlacementConstraintsParameters `json:"placementConstraints,omitempty" tf:"placement_constraints"`

	// +kubebuilder:validation:Optional
	ProxyConfiguration []ProxyConfigurationParameters `json:"proxyConfiguration,omitempty" tf:"proxy_configuration"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	RequiresCompatibilities []string `json:"requiresCompatibilities,omitempty" tf:"requires_compatibilities"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Optional
	TagsAll map[string]string `json:"tagsAll,omitempty" tf:"tags_all"`

	// +kubebuilder:validation:Optional
	TaskRoleArn *string `json:"taskRoleArn,omitempty" tf:"task_role_arn"`

	// +kubebuilder:validation:Optional
	Volume []VolumeParameters `json:"volume,omitempty" tf:"volume"`
}

type EcsTaskDefinitionPlacementConstraintsObservation struct {
}

type EcsTaskDefinitionPlacementConstraintsParameters struct {

	// +kubebuilder:validation:Optional
	Expression *string `json:"expression,omitempty" tf:"expression"`

	// +kubebuilder:validation:Required
	Type string `json:"type" tf:"type"`
}

type EfsVolumeConfigurationObservation struct {
}

type EfsVolumeConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	AuthorizationConfig []AuthorizationConfigParameters `json:"authorizationConfig,omitempty" tf:"authorization_config"`

	// +kubebuilder:validation:Required
	FileSystemID string `json:"fileSystemId" tf:"file_system_id"`

	// +kubebuilder:validation:Optional
	RootDirectory *string `json:"rootDirectory,omitempty" tf:"root_directory"`

	// +kubebuilder:validation:Optional
	TransitEncryption *string `json:"transitEncryption,omitempty" tf:"transit_encryption"`

	// +kubebuilder:validation:Optional
	TransitEncryptionPort *int64 `json:"transitEncryptionPort,omitempty" tf:"transit_encryption_port"`
}

type EphemeralStorageObservation struct {
}

type EphemeralStorageParameters struct {

	// +kubebuilder:validation:Required
	SizeInGib int64 `json:"sizeInGib" tf:"size_in_gib"`
}

type FsxWindowsFileServerVolumeConfigurationAuthorizationConfigObservation struct {
}

type FsxWindowsFileServerVolumeConfigurationAuthorizationConfigParameters struct {

	// +kubebuilder:validation:Required
	CredentialsParameter string `json:"credentialsParameter" tf:"credentials_parameter"`

	// +kubebuilder:validation:Required
	Domain string `json:"domain" tf:"domain"`
}

type FsxWindowsFileServerVolumeConfigurationObservation struct {
}

type FsxWindowsFileServerVolumeConfigurationParameters struct {

	// +kubebuilder:validation:Required
	AuthorizationConfig []FsxWindowsFileServerVolumeConfigurationAuthorizationConfigParameters `json:"authorizationConfig" tf:"authorization_config"`

	// +kubebuilder:validation:Required
	FileSystemID string `json:"fileSystemId" tf:"file_system_id"`

	// +kubebuilder:validation:Required
	RootDirectory string `json:"rootDirectory" tf:"root_directory"`
}

type InferenceAcceleratorObservation struct {
}

type InferenceAcceleratorParameters struct {

	// +kubebuilder:validation:Required
	DeviceName string `json:"deviceName" tf:"device_name"`

	// +kubebuilder:validation:Required
	DeviceType string `json:"deviceType" tf:"device_type"`
}

type ProxyConfigurationObservation struct {
}

type ProxyConfigurationParameters struct {

	// +kubebuilder:validation:Required
	ContainerName string `json:"containerName" tf:"container_name"`

	// +kubebuilder:validation:Optional
	Properties map[string]string `json:"properties,omitempty" tf:"properties"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type"`
}

type VolumeObservation struct {
}

type VolumeParameters struct {

	// +kubebuilder:validation:Optional
	DockerVolumeConfiguration []DockerVolumeConfigurationParameters `json:"dockerVolumeConfiguration,omitempty" tf:"docker_volume_configuration"`

	// +kubebuilder:validation:Optional
	EfsVolumeConfiguration []EfsVolumeConfigurationParameters `json:"efsVolumeConfiguration,omitempty" tf:"efs_volume_configuration"`

	// +kubebuilder:validation:Optional
	FsxWindowsFileServerVolumeConfiguration []FsxWindowsFileServerVolumeConfigurationParameters `json:"fsxWindowsFileServerVolumeConfiguration,omitempty" tf:"fsx_windows_file_server_volume_configuration"`

	// +kubebuilder:validation:Optional
	HostPath *string `json:"hostPath,omitempty" tf:"host_path"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`
}

// EcsTaskDefinitionSpec defines the desired state of EcsTaskDefinition
type EcsTaskDefinitionSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       EcsTaskDefinitionParameters `json:"forProvider"`
}

// EcsTaskDefinitionStatus defines the observed state of EcsTaskDefinition.
type EcsTaskDefinitionStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          EcsTaskDefinitionObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// EcsTaskDefinition is the Schema for the EcsTaskDefinitions API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type EcsTaskDefinition struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              EcsTaskDefinitionSpec   `json:"spec"`
	Status            EcsTaskDefinitionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// EcsTaskDefinitionList contains a list of EcsTaskDefinitions
type EcsTaskDefinitionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []EcsTaskDefinition `json:"items"`
}

// Repository type metadata.
var (
	EcsTaskDefinitionKind             = "EcsTaskDefinition"
	EcsTaskDefinitionGroupKind        = schema.GroupKind{Group: Group, Kind: EcsTaskDefinitionKind}.String()
	EcsTaskDefinitionKindAPIVersion   = EcsTaskDefinitionKind + "." + GroupVersion.String()
	EcsTaskDefinitionGroupVersionKind = GroupVersion.WithKind(EcsTaskDefinitionKind)
)

func init() {
	SchemeBuilder.Register(&EcsTaskDefinition{}, &EcsTaskDefinitionList{})
}
