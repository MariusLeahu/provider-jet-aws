/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AuthorizationConfigObservation struct {
}

type AuthorizationConfigParameters struct {

	// +kubebuilder:validation:Optional
	AccessPointID *string `json:"accessPointId,omitempty" tf:"access_point_id"`

	// +kubebuilder:validation:Optional
	Iam *string `json:"iam,omitempty" tf:"iam"`
}

type DockerVolumeConfigurationObservation struct {
}

type DockerVolumeConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	Autoprovision *bool `json:"autoprovision,omitempty" tf:"autoprovision"`

	// +kubebuilder:validation:Optional
	Driver *string `json:"driver,omitempty" tf:"driver"`

	// +kubebuilder:validation:Optional
	DriverOpts map[string]*string `json:"driverOpts,omitempty" tf:"driver_opts"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels"`

	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope"`
}

type EfsVolumeConfigurationObservation struct {
}

type EfsVolumeConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	AuthorizationConfig []AuthorizationConfigParameters `json:"authorizationConfig,omitempty" tf:"authorization_config"`

	// +kubebuilder:validation:Required
	FileSystemID *string `json:"fileSystemId" tf:"file_system_id"`

	// +kubebuilder:validation:Optional
	RootDirectory *string `json:"rootDirectory,omitempty" tf:"root_directory"`

	// +kubebuilder:validation:Optional
	TransitEncryption *string `json:"transitEncryption,omitempty" tf:"transit_encryption"`

	// +kubebuilder:validation:Optional
	TransitEncryptionPort *int64 `json:"transitEncryptionPort,omitempty" tf:"transit_encryption_port"`
}

type EphemeralStorageObservation struct {
}

type EphemeralStorageParameters struct {

	// +kubebuilder:validation:Required
	SizeInGib *int64 `json:"sizeInGib" tf:"size_in_gib"`
}

type FsxWindowsFileServerVolumeConfigurationAuthorizationConfigObservation struct {
}

type FsxWindowsFileServerVolumeConfigurationAuthorizationConfigParameters struct {

	// +kubebuilder:validation:Required
	CredentialsParameter *string `json:"credentialsParameter" tf:"credentials_parameter"`

	// +kubebuilder:validation:Required
	Domain *string `json:"domain" tf:"domain"`
}

type FsxWindowsFileServerVolumeConfigurationObservation struct {
}

type FsxWindowsFileServerVolumeConfigurationParameters struct {

	// +kubebuilder:validation:Required
	AuthorizationConfig []FsxWindowsFileServerVolumeConfigurationAuthorizationConfigParameters `json:"authorizationConfig" tf:"authorization_config"`

	// +kubebuilder:validation:Required
	FileSystemID *string `json:"fileSystemId" tf:"file_system_id"`

	// +kubebuilder:validation:Required
	RootDirectory *string `json:"rootDirectory" tf:"root_directory"`
}

type InferenceAcceleratorObservation struct {
}

type InferenceAcceleratorParameters struct {

	// +kubebuilder:validation:Required
	DeviceName *string `json:"deviceName" tf:"device_name"`

	// +kubebuilder:validation:Required
	DeviceType *string `json:"deviceType" tf:"device_type"`
}

type ProxyConfigurationObservation struct {
}

type ProxyConfigurationParameters struct {

	// +kubebuilder:validation:Required
	ContainerName *string `json:"containerName" tf:"container_name"`

	// +kubebuilder:validation:Optional
	Properties map[string]*string `json:"properties,omitempty" tf:"properties"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type"`
}

type TaskDefinitionObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn"`

	Revision *int64 `json:"revision,omitempty" tf:"revision"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all"`
}

type TaskDefinitionParameters struct {

	// +kubebuilder:validation:Optional
	CPU *string `json:"cpu,omitempty" tf:"cpu"`

	// +kubebuilder:validation:Required
	ContainerDefinitions *string `json:"containerDefinitions" tf:"container_definitions"`

	// +kubebuilder:validation:Optional
	EphemeralStorage []EphemeralStorageParameters `json:"ephemeralStorage,omitempty" tf:"ephemeral_storage"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-tf-aws/apis/iam/v1alpha1.Role
	// +crossplane:generate:reference:extractor=github.com/crossplane-contrib/provider-tf-aws/config/common.ARNExtractor()
	// +kubebuilder:validation:Optional
	ExecutionRoleArn *string `json:"executionRoleArn,omitempty" tf:"execution_role_arn"`

	// +kubebuilder:validation:Optional
	ExecutionRoleArnRef *v1.Reference `json:"executionRoleArnRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ExecutionRoleArnSelector *v1.Selector `json:"executionRoleArnSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	Family *string `json:"family" tf:"family"`

	// +kubebuilder:validation:Optional
	InferenceAccelerator []InferenceAcceleratorParameters `json:"inferenceAccelerator,omitempty" tf:"inference_accelerator"`

	// +kubebuilder:validation:Optional
	IpcMode *string `json:"ipcMode,omitempty" tf:"ipc_mode"`

	// +kubebuilder:validation:Optional
	Memory *string `json:"memory,omitempty" tf:"memory"`

	// +kubebuilder:validation:Optional
	NetworkMode *string `json:"networkMode,omitempty" tf:"network_mode"`

	// +kubebuilder:validation:Optional
	PidMode *string `json:"pidMode,omitempty" tf:"pid_mode"`

	// +kubebuilder:validation:Optional
	PlacementConstraints []TaskDefinitionPlacementConstraintsParameters `json:"placementConstraints,omitempty" tf:"placement_constraints"`

	// +kubebuilder:validation:Optional
	ProxyConfiguration []ProxyConfigurationParameters `json:"proxyConfiguration,omitempty" tf:"proxy_configuration"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	RequiresCompatibilities []*string `json:"requiresCompatibilities,omitempty" tf:"requires_compatibilities"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Optional
	TaskRoleArn *string `json:"taskRoleArn,omitempty" tf:"task_role_arn"`

	// +kubebuilder:validation:Optional
	Volume []VolumeParameters `json:"volume,omitempty" tf:"volume"`
}

type TaskDefinitionPlacementConstraintsObservation struct {
}

type TaskDefinitionPlacementConstraintsParameters struct {

	// +kubebuilder:validation:Optional
	Expression *string `json:"expression,omitempty" tf:"expression"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type"`
}

type VolumeObservation struct {
}

type VolumeParameters struct {

	// +kubebuilder:validation:Optional
	DockerVolumeConfiguration []DockerVolumeConfigurationParameters `json:"dockerVolumeConfiguration,omitempty" tf:"docker_volume_configuration"`

	// +kubebuilder:validation:Optional
	EfsVolumeConfiguration []EfsVolumeConfigurationParameters `json:"efsVolumeConfiguration,omitempty" tf:"efs_volume_configuration"`

	// +kubebuilder:validation:Optional
	FsxWindowsFileServerVolumeConfiguration []FsxWindowsFileServerVolumeConfigurationParameters `json:"fsxWindowsFileServerVolumeConfiguration,omitempty" tf:"fsx_windows_file_server_volume_configuration"`

	// +kubebuilder:validation:Optional
	HostPath *string `json:"hostPath,omitempty" tf:"host_path"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name"`
}

// TaskDefinitionSpec defines the desired state of TaskDefinition
type TaskDefinitionSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TaskDefinitionParameters `json:"forProvider"`
}

// TaskDefinitionStatus defines the observed state of TaskDefinition.
type TaskDefinitionStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TaskDefinitionObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// TaskDefinition is the Schema for the TaskDefinitions API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type TaskDefinition struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TaskDefinitionSpec   `json:"spec"`
	Status            TaskDefinitionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TaskDefinitionList contains a list of TaskDefinitions
type TaskDefinitionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TaskDefinition `json:"items"`
}

// Repository type metadata.
var (
	TaskDefinitionKind             = "TaskDefinition"
	TaskDefinitionGroupKind        = schema.GroupKind{Group: Group, Kind: TaskDefinitionKind}.String()
	TaskDefinitionKindAPIVersion   = TaskDefinitionKind + "." + GroupVersion.String()
	TaskDefinitionGroupVersionKind = GroupVersion.WithKind(TaskDefinitionKind)
)

func init() {
	SchemeBuilder.Register(&TaskDefinition{}, &TaskDefinitionList{})
}
