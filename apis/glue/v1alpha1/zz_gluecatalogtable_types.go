/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type ColumnsObservation struct {
}

type ColumnsParameters struct {

	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	Parameters map[string]string `json:"parameters,omitempty" tf:"parameters"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type"`
}

type GlueCatalogTableObservation struct {
	Arn string `json:"arn" tf:"arn"`
}

type GlueCatalogTableParameters struct {

	// +kubebuilder:validation:Optional
	CatalogID *string `json:"catalogId,omitempty" tf:"catalog_id"`

	// +kubebuilder:validation:Required
	DatabaseName string `json:"databaseName" tf:"database_name"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	Owner *string `json:"owner,omitempty" tf:"owner"`

	// +kubebuilder:validation:Optional
	Parameters map[string]string `json:"parameters,omitempty" tf:"parameters"`

	// +kubebuilder:validation:Optional
	PartitionIndex []PartitionIndexParameters `json:"partitionIndex,omitempty" tf:"partition_index"`

	// +kubebuilder:validation:Optional
	PartitionKeys []PartitionKeysParameters `json:"partitionKeys,omitempty" tf:"partition_keys"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	Retention *int64 `json:"retention,omitempty" tf:"retention"`

	// +kubebuilder:validation:Optional
	StorageDescriptor []StorageDescriptorParameters `json:"storageDescriptor,omitempty" tf:"storage_descriptor"`

	// +kubebuilder:validation:Optional
	TableType *string `json:"tableType,omitempty" tf:"table_type"`

	// +kubebuilder:validation:Optional
	TargetTable []TargetTableParameters `json:"targetTable,omitempty" tf:"target_table"`

	// +kubebuilder:validation:Optional
	ViewExpandedText *string `json:"viewExpandedText,omitempty" tf:"view_expanded_text"`

	// +kubebuilder:validation:Optional
	ViewOriginalText *string `json:"viewOriginalText,omitempty" tf:"view_original_text"`
}

type PartitionIndexObservation struct {
	IndexStatus string `json:"indexStatus" tf:"index_status"`
}

type PartitionIndexParameters struct {

	// +kubebuilder:validation:Required
	IndexName string `json:"indexName" tf:"index_name"`

	// +kubebuilder:validation:Required
	Keys []string `json:"keys" tf:"keys"`
}

type PartitionKeysObservation struct {
}

type PartitionKeysParameters struct {

	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type"`
}

type SchemaIDObservation struct {
}

type SchemaIDParameters struct {

	// +kubebuilder:validation:Optional
	RegistryName *string `json:"registryName,omitempty" tf:"registry_name"`

	// +kubebuilder:validation:Optional
	SchemaArn *string `json:"schemaArn,omitempty" tf:"schema_arn"`

	// +kubebuilder:validation:Optional
	SchemaName *string `json:"schemaName,omitempty" tf:"schema_name"`
}

type SchemaReferenceObservation struct {
}

type SchemaReferenceParameters struct {

	// +kubebuilder:validation:Optional
	SchemaID []SchemaIDParameters `json:"schemaId,omitempty" tf:"schema_id"`

	// +kubebuilder:validation:Optional
	SchemaVersionID *string `json:"schemaVersionId,omitempty" tf:"schema_version_id"`

	// +kubebuilder:validation:Required
	SchemaVersionNumber int64 `json:"schemaVersionNumber" tf:"schema_version_number"`
}

type SerDeInfoObservation struct {
}

type SerDeInfoParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name"`

	// +kubebuilder:validation:Optional
	Parameters map[string]string `json:"parameters,omitempty" tf:"parameters"`

	// +kubebuilder:validation:Optional
	SerializationLibrary *string `json:"serializationLibrary,omitempty" tf:"serialization_library"`
}

type SkewedInfoObservation struct {
}

type SkewedInfoParameters struct {

	// +kubebuilder:validation:Optional
	SkewedColumnNames []string `json:"skewedColumnNames,omitempty" tf:"skewed_column_names"`

	// +kubebuilder:validation:Optional
	SkewedColumnValueLocationMaps map[string]string `json:"skewedColumnValueLocationMaps,omitempty" tf:"skewed_column_value_location_maps"`

	// +kubebuilder:validation:Optional
	SkewedColumnValues []string `json:"skewedColumnValues,omitempty" tf:"skewed_column_values"`
}

type SortColumnsObservation struct {
}

type SortColumnsParameters struct {

	// +kubebuilder:validation:Required
	Column string `json:"column" tf:"column"`

	// +kubebuilder:validation:Required
	SortOrder int64 `json:"sortOrder" tf:"sort_order"`
}

type StorageDescriptorObservation struct {
}

type StorageDescriptorParameters struct {

	// +kubebuilder:validation:Optional
	BucketColumns []string `json:"bucketColumns,omitempty" tf:"bucket_columns"`

	// +kubebuilder:validation:Optional
	Columns []ColumnsParameters `json:"columns,omitempty" tf:"columns"`

	// +kubebuilder:validation:Optional
	Compressed *bool `json:"compressed,omitempty" tf:"compressed"`

	// +kubebuilder:validation:Optional
	InputFormat *string `json:"inputFormat,omitempty" tf:"input_format"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location"`

	// +kubebuilder:validation:Optional
	NumberOfBuckets *int64 `json:"numberOfBuckets,omitempty" tf:"number_of_buckets"`

	// +kubebuilder:validation:Optional
	OutputFormat *string `json:"outputFormat,omitempty" tf:"output_format"`

	// +kubebuilder:validation:Optional
	Parameters map[string]string `json:"parameters,omitempty" tf:"parameters"`

	// +kubebuilder:validation:Optional
	SchemaReference []SchemaReferenceParameters `json:"schemaReference,omitempty" tf:"schema_reference"`

	// +kubebuilder:validation:Optional
	SerDeInfo []SerDeInfoParameters `json:"serDeInfo,omitempty" tf:"ser_de_info"`

	// +kubebuilder:validation:Optional
	SkewedInfo []SkewedInfoParameters `json:"skewedInfo,omitempty" tf:"skewed_info"`

	// +kubebuilder:validation:Optional
	SortColumns []SortColumnsParameters `json:"sortColumns,omitempty" tf:"sort_columns"`

	// +kubebuilder:validation:Optional
	StoredAsSubDirectories *bool `json:"storedAsSubDirectories,omitempty" tf:"stored_as_sub_directories"`
}

type TargetTableObservation struct {
}

type TargetTableParameters struct {

	// +kubebuilder:validation:Required
	CatalogID string `json:"catalogId" tf:"catalog_id"`

	// +kubebuilder:validation:Required
	DatabaseName string `json:"databaseName" tf:"database_name"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`
}

// GlueCatalogTableSpec defines the desired state of GlueCatalogTable
type GlueCatalogTableSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       GlueCatalogTableParameters `json:"forProvider"`
}

// GlueCatalogTableStatus defines the observed state of GlueCatalogTable.
type GlueCatalogTableStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          GlueCatalogTableObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// GlueCatalogTable is the Schema for the GlueCatalogTables API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type GlueCatalogTable struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              GlueCatalogTableSpec   `json:"spec"`
	Status            GlueCatalogTableStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// GlueCatalogTableList contains a list of GlueCatalogTables
type GlueCatalogTableList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []GlueCatalogTable `json:"items"`
}

// Repository type metadata.
var (
	GlueCatalogTableKind             = "GlueCatalogTable"
	GlueCatalogTableGroupKind        = schema.GroupKind{Group: Group, Kind: GlueCatalogTableKind}.String()
	GlueCatalogTableKindAPIVersion   = GlueCatalogTableKind + "." + GroupVersion.String()
	GlueCatalogTableGroupVersionKind = GroupVersion.WithKind(GlueCatalogTableKind)
)

func init() {
	SchemeBuilder.Register(&GlueCatalogTable{}, &GlueCatalogTableList{})
}
