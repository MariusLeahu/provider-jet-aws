/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type CatalogTargetObservation struct {
}

type CatalogTargetParameters struct {

	// +kubebuilder:validation:Required
	DatabaseName string `json:"databaseName" tf:"database_name"`

	// +kubebuilder:validation:Required
	Tables []string `json:"tables" tf:"tables"`
}

type DynamodbTargetObservation struct {
}

type DynamodbTargetParameters struct {

	// +kubebuilder:validation:Required
	Path string `json:"path" tf:"path"`

	// +kubebuilder:validation:Optional
	ScanAll *bool `json:"scanAll,omitempty" tf:"scan_all"`

	// +kubebuilder:validation:Optional
	ScanRate *float64 `json:"scanRate,omitempty" tf:"scan_rate"`
}

type GlueCrawlerObservation struct {
	Arn string `json:"arn" tf:"arn"`
}

type GlueCrawlerParameters struct {

	// +kubebuilder:validation:Optional
	CatalogTarget []CatalogTargetParameters `json:"catalogTarget,omitempty" tf:"catalog_target"`

	// +kubebuilder:validation:Optional
	Classifiers []string `json:"classifiers,omitempty" tf:"classifiers"`

	// +kubebuilder:validation:Optional
	Configuration *string `json:"configuration,omitempty" tf:"configuration"`

	// +kubebuilder:validation:Required
	DatabaseName string `json:"databaseName" tf:"database_name"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description"`

	// +kubebuilder:validation:Optional
	DynamodbTarget []DynamodbTargetParameters `json:"dynamodbTarget,omitempty" tf:"dynamodb_target"`

	// +kubebuilder:validation:Optional
	JdbcTarget []JdbcTargetParameters `json:"jdbcTarget,omitempty" tf:"jdbc_target"`

	// +kubebuilder:validation:Optional
	LineageConfiguration []LineageConfigurationParameters `json:"lineageConfiguration,omitempty" tf:"lineage_configuration"`

	// +kubebuilder:validation:Optional
	MongodbTarget []MongodbTargetParameters `json:"mongodbTarget,omitempty" tf:"mongodb_target"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	RecrawlPolicy []RecrawlPolicyParameters `json:"recrawlPolicy,omitempty" tf:"recrawl_policy"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region string `json:"region" tf:"-"`

	// +kubebuilder:validation:Required
	Role string `json:"role" tf:"role"`

	// +kubebuilder:validation:Optional
	S3Target []S3TargetParameters `json:"s3Target,omitempty" tf:"s3_target"`

	// +kubebuilder:validation:Optional
	Schedule *string `json:"schedule,omitempty" tf:"schedule"`

	// +kubebuilder:validation:Optional
	SchemaChangePolicy []SchemaChangePolicyParameters `json:"schemaChangePolicy,omitempty" tf:"schema_change_policy"`

	// +kubebuilder:validation:Optional
	SecurityConfiguration *string `json:"securityConfiguration,omitempty" tf:"security_configuration"`

	// +kubebuilder:validation:Optional
	TablePrefix *string `json:"tablePrefix,omitempty" tf:"table_prefix"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Optional
	TagsAll map[string]string `json:"tagsAll,omitempty" tf:"tags_all"`
}

type JdbcTargetObservation struct {
}

type JdbcTargetParameters struct {

	// +kubebuilder:validation:Required
	ConnectionName string `json:"connectionName" tf:"connection_name"`

	// +kubebuilder:validation:Optional
	Exclusions []string `json:"exclusions,omitempty" tf:"exclusions"`

	// +kubebuilder:validation:Required
	Path string `json:"path" tf:"path"`
}

type LineageConfigurationObservation struct {
}

type LineageConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	CrawlerLineageSettings *string `json:"crawlerLineageSettings,omitempty" tf:"crawler_lineage_settings"`
}

type MongodbTargetObservation struct {
}

type MongodbTargetParameters struct {

	// +kubebuilder:validation:Required
	ConnectionName string `json:"connectionName" tf:"connection_name"`

	// +kubebuilder:validation:Required
	Path string `json:"path" tf:"path"`

	// +kubebuilder:validation:Optional
	ScanAll *bool `json:"scanAll,omitempty" tf:"scan_all"`
}

type RecrawlPolicyObservation struct {
}

type RecrawlPolicyParameters struct {

	// +kubebuilder:validation:Optional
	RecrawlBehavior *string `json:"recrawlBehavior,omitempty" tf:"recrawl_behavior"`
}

type S3TargetObservation struct {
}

type S3TargetParameters struct {

	// +kubebuilder:validation:Optional
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name"`

	// +kubebuilder:validation:Optional
	Exclusions []string `json:"exclusions,omitempty" tf:"exclusions"`

	// +kubebuilder:validation:Required
	Path string `json:"path" tf:"path"`

	// +kubebuilder:validation:Optional
	SampleSize *int64 `json:"sampleSize,omitempty" tf:"sample_size"`
}

type SchemaChangePolicyObservation struct {
}

type SchemaChangePolicyParameters struct {

	// +kubebuilder:validation:Optional
	DeleteBehavior *string `json:"deleteBehavior,omitempty" tf:"delete_behavior"`

	// +kubebuilder:validation:Optional
	UpdateBehavior *string `json:"updateBehavior,omitempty" tf:"update_behavior"`
}

// GlueCrawlerSpec defines the desired state of GlueCrawler
type GlueCrawlerSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       GlueCrawlerParameters `json:"forProvider"`
}

// GlueCrawlerStatus defines the observed state of GlueCrawler.
type GlueCrawlerStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          GlueCrawlerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// GlueCrawler is the Schema for the GlueCrawlers API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type GlueCrawler struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              GlueCrawlerSpec   `json:"spec"`
	Status            GlueCrawlerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// GlueCrawlerList contains a list of GlueCrawlers
type GlueCrawlerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []GlueCrawler `json:"items"`
}

// Repository type metadata.
var (
	GlueCrawlerKind             = "GlueCrawler"
	GlueCrawlerGroupKind        = schema.GroupKind{Group: Group, Kind: GlueCrawlerKind}.String()
	GlueCrawlerKindAPIVersion   = GlueCrawlerKind + "." + GroupVersion.String()
	GlueCrawlerGroupVersionKind = GroupVersion.WithKind(GlueCrawlerKind)
)

func init() {
	SchemeBuilder.Register(&GlueCrawler{}, &GlueCrawlerList{})
}
