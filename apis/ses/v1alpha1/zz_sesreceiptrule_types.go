/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type AddHeaderActionObservation struct {
}

type AddHeaderActionParameters struct {

	// +kubebuilder:validation:Required
	HeaderName string `json:"headerName" tf:"header_name"`

	// +kubebuilder:validation:Required
	HeaderValue string `json:"headerValue" tf:"header_value"`

	// +kubebuilder:validation:Required
	Position int64 `json:"position" tf:"position"`
}

type BounceActionObservation struct {
}

type BounceActionParameters struct {

	// +kubebuilder:validation:Required
	Message string `json:"message" tf:"message"`

	// +kubebuilder:validation:Required
	Position int64 `json:"position" tf:"position"`

	// +kubebuilder:validation:Required
	SMTPReplyCode string `json:"smtpReplyCode" tf:"smtp_reply_code"`

	// +kubebuilder:validation:Required
	Sender string `json:"sender" tf:"sender"`

	// +kubebuilder:validation:Optional
	StatusCode *string `json:"statusCode,omitempty" tf:"status_code"`

	// +kubebuilder:validation:Optional
	TopicArn *string `json:"topicArn,omitempty" tf:"topic_arn"`
}

type LambdaActionObservation struct {
}

type LambdaActionParameters struct {

	// +kubebuilder:validation:Required
	FunctionArn string `json:"functionArn" tf:"function_arn"`

	// +kubebuilder:validation:Optional
	InvocationType *string `json:"invocationType,omitempty" tf:"invocation_type"`

	// +kubebuilder:validation:Required
	Position int64 `json:"position" tf:"position"`

	// +kubebuilder:validation:Optional
	TopicArn *string `json:"topicArn,omitempty" tf:"topic_arn"`
}

type S3ActionObservation struct {
}

type S3ActionParameters struct {

	// +kubebuilder:validation:Required
	BucketName string `json:"bucketName" tf:"bucket_name"`

	// +kubebuilder:validation:Optional
	KmsKeyArn *string `json:"kmsKeyArn,omitempty" tf:"kms_key_arn"`

	// +kubebuilder:validation:Optional
	ObjectKeyPrefix *string `json:"objectKeyPrefix,omitempty" tf:"object_key_prefix"`

	// +kubebuilder:validation:Required
	Position int64 `json:"position" tf:"position"`

	// +kubebuilder:validation:Optional
	TopicArn *string `json:"topicArn,omitempty" tf:"topic_arn"`
}

type SesReceiptRuleObservation struct {
	Arn string `json:"arn" tf:"arn"`
}

type SesReceiptRuleParameters struct {

	// +kubebuilder:validation:Optional
	AddHeaderAction []AddHeaderActionParameters `json:"addHeaderAction,omitempty" tf:"add_header_action"`

	// +kubebuilder:validation:Optional
	After *string `json:"after,omitempty" tf:"after"`

	// +kubebuilder:validation:Optional
	BounceAction []BounceActionParameters `json:"bounceAction,omitempty" tf:"bounce_action"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`

	// +kubebuilder:validation:Optional
	LambdaAction []LambdaActionParameters `json:"lambdaAction,omitempty" tf:"lambda_action"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	Recipients []string `json:"recipients,omitempty" tf:"recipients"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region string `json:"region" tf:"-"`

	// +kubebuilder:validation:Required
	RuleSetName string `json:"ruleSetName" tf:"rule_set_name"`

	// +kubebuilder:validation:Optional
	S3Action []S3ActionParameters `json:"s3Action,omitempty" tf:"s3_action"`

	// +kubebuilder:validation:Optional
	ScanEnabled *bool `json:"scanEnabled,omitempty" tf:"scan_enabled"`

	// +kubebuilder:validation:Optional
	SnsAction []SnsActionParameters `json:"snsAction,omitempty" tf:"sns_action"`

	// +kubebuilder:validation:Optional
	StopAction []StopActionParameters `json:"stopAction,omitempty" tf:"stop_action"`

	// +kubebuilder:validation:Optional
	TLSPolicy *string `json:"tlsPolicy,omitempty" tf:"tls_policy"`

	// +kubebuilder:validation:Optional
	WorkmailAction []WorkmailActionParameters `json:"workmailAction,omitempty" tf:"workmail_action"`
}

type SnsActionObservation struct {
}

type SnsActionParameters struct {

	// +kubebuilder:validation:Optional
	Encoding *string `json:"encoding,omitempty" tf:"encoding"`

	// +kubebuilder:validation:Required
	Position int64 `json:"position" tf:"position"`

	// +kubebuilder:validation:Required
	TopicArn string `json:"topicArn" tf:"topic_arn"`
}

type StopActionObservation struct {
}

type StopActionParameters struct {

	// +kubebuilder:validation:Required
	Position int64 `json:"position" tf:"position"`

	// +kubebuilder:validation:Required
	Scope string `json:"scope" tf:"scope"`

	// +kubebuilder:validation:Optional
	TopicArn *string `json:"topicArn,omitempty" tf:"topic_arn"`
}

type WorkmailActionObservation struct {
}

type WorkmailActionParameters struct {

	// +kubebuilder:validation:Required
	OrganizationArn string `json:"organizationArn" tf:"organization_arn"`

	// +kubebuilder:validation:Required
	Position int64 `json:"position" tf:"position"`

	// +kubebuilder:validation:Optional
	TopicArn *string `json:"topicArn,omitempty" tf:"topic_arn"`
}

// SesReceiptRuleSpec defines the desired state of SesReceiptRule
type SesReceiptRuleSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       SesReceiptRuleParameters `json:"forProvider"`
}

// SesReceiptRuleStatus defines the observed state of SesReceiptRule.
type SesReceiptRuleStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          SesReceiptRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// SesReceiptRule is the Schema for the SesReceiptRules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type SesReceiptRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SesReceiptRuleSpec   `json:"spec"`
	Status            SesReceiptRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SesReceiptRuleList contains a list of SesReceiptRules
type SesReceiptRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SesReceiptRule `json:"items"`
}

// Repository type metadata.
var (
	SesReceiptRuleKind             = "SesReceiptRule"
	SesReceiptRuleGroupKind        = schema.GroupKind{Group: Group, Kind: SesReceiptRuleKind}.String()
	SesReceiptRuleKindAPIVersion   = SesReceiptRuleKind + "." + GroupVersion.String()
	SesReceiptRuleGroupVersionKind = GroupVersion.WithKind(SesReceiptRuleKind)
)

func init() {
	SchemeBuilder.Register(&SesReceiptRule{}, &SesReceiptRuleList{})
}
