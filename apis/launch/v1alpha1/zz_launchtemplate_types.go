/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type BlockDeviceMappingsObservation struct {
}

type BlockDeviceMappingsParameters struct {

	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name"`

	// +kubebuilder:validation:Optional
	Ebs []EbsParameters `json:"ebs,omitempty" tf:"ebs"`

	// +kubebuilder:validation:Optional
	NoDevice *string `json:"noDevice,omitempty" tf:"no_device"`

	// +kubebuilder:validation:Optional
	VirtualName *string `json:"virtualName,omitempty" tf:"virtual_name"`
}

type CPUOptionsObservation struct {
}

type CPUOptionsParameters struct {

	// +kubebuilder:validation:Optional
	CoreCount *int64 `json:"coreCount,omitempty" tf:"core_count"`

	// +kubebuilder:validation:Optional
	ThreadsPerCore *int64 `json:"threadsPerCore,omitempty" tf:"threads_per_core"`
}

type CapacityReservationSpecificationObservation struct {
}

type CapacityReservationSpecificationParameters struct {

	// +kubebuilder:validation:Optional
	CapacityReservationPreference *string `json:"capacityReservationPreference,omitempty" tf:"capacity_reservation_preference"`

	// +kubebuilder:validation:Optional
	CapacityReservationTarget []CapacityReservationTargetParameters `json:"capacityReservationTarget,omitempty" tf:"capacity_reservation_target"`
}

type CapacityReservationTargetObservation struct {
}

type CapacityReservationTargetParameters struct {

	// +kubebuilder:validation:Optional
	CapacityReservationID *string `json:"capacityReservationId,omitempty" tf:"capacity_reservation_id"`
}

type CreditSpecificationObservation struct {
}

type CreditSpecificationParameters struct {

	// +kubebuilder:validation:Optional
	CPUCredits *string `json:"cpuCredits,omitempty" tf:"cpu_credits"`
}

type EbsObservation struct {
}

type EbsParameters struct {

	// +kubebuilder:validation:Optional
	DeleteOnTermination *string `json:"deleteOnTermination,omitempty" tf:"delete_on_termination"`

	// +kubebuilder:validation:Optional
	Encrypted *string `json:"encrypted,omitempty" tf:"encrypted"`

	// +kubebuilder:validation:Optional
	Iops *int64 `json:"iops,omitempty" tf:"iops"`

	// +kubebuilder:validation:Optional
	KmsKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id"`

	// +kubebuilder:validation:Optional
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id"`

	// +kubebuilder:validation:Optional
	Throughput *int64 `json:"throughput,omitempty" tf:"throughput"`

	// +kubebuilder:validation:Optional
	VolumeSize *int64 `json:"volumeSize,omitempty" tf:"volume_size"`

	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type"`
}

type ElasticGpuSpecificationsObservation struct {
}

type ElasticGpuSpecificationsParameters struct {

	// +kubebuilder:validation:Required
	Type string `json:"type" tf:"type"`
}

type ElasticInferenceAcceleratorObservation struct {
}

type ElasticInferenceAcceleratorParameters struct {

	// +kubebuilder:validation:Required
	Type string `json:"type" tf:"type"`
}

type EnclaveOptionsObservation struct {
}

type EnclaveOptionsParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
}

type HibernationOptionsObservation struct {
}

type HibernationOptionsParameters struct {

	// +kubebuilder:validation:Required
	Configured bool `json:"configured" tf:"configured"`
}

type IamInstanceProfileObservation struct {
}

type IamInstanceProfileParameters struct {

	// +kubebuilder:validation:Optional
	Arn *string `json:"arn,omitempty" tf:"arn"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name"`
}

type InstanceMarketOptionsObservation struct {
}

type InstanceMarketOptionsParameters struct {

	// +kubebuilder:validation:Optional
	MarketType *string `json:"marketType,omitempty" tf:"market_type"`

	// +kubebuilder:validation:Optional
	SpotOptions []SpotOptionsParameters `json:"spotOptions,omitempty" tf:"spot_options"`
}

type LaunchTemplateMetadataOptionsObservation struct {
}

type LaunchTemplateMetadataOptionsParameters struct {

	// +kubebuilder:validation:Optional
	HTTPEndpoint *string `json:"httpEndpoint,omitempty" tf:"http_endpoint"`

	// +kubebuilder:validation:Optional
	HTTPPutResponseHopLimit *int64 `json:"httpPutResponseHopLimit,omitempty" tf:"http_put_response_hop_limit"`

	// +kubebuilder:validation:Optional
	HTTPTokens *string `json:"httpTokens,omitempty" tf:"http_tokens"`
}

type LaunchTemplateObservation struct {
	Arn string `json:"arn" tf:"arn"`

	LatestVersion int64 `json:"latestVersion" tf:"latest_version"`
}

type LaunchTemplateParameters struct {

	// +kubebuilder:validation:Optional
	BlockDeviceMappings []BlockDeviceMappingsParameters `json:"blockDeviceMappings,omitempty" tf:"block_device_mappings"`

	// +kubebuilder:validation:Optional
	CPUOptions []CPUOptionsParameters `json:"cpuOptions,omitempty" tf:"cpu_options"`

	// +kubebuilder:validation:Optional
	CapacityReservationSpecification []CapacityReservationSpecificationParameters `json:"capacityReservationSpecification,omitempty" tf:"capacity_reservation_specification"`

	// +kubebuilder:validation:Optional
	CreditSpecification []CreditSpecificationParameters `json:"creditSpecification,omitempty" tf:"credit_specification"`

	// +kubebuilder:validation:Optional
	DefaultVersion *int64 `json:"defaultVersion,omitempty" tf:"default_version"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description"`

	// +kubebuilder:validation:Optional
	DisableAPITermination *bool `json:"disableApiTermination,omitempty" tf:"disable_api_termination"`

	// +kubebuilder:validation:Optional
	EbsOptimized *string `json:"ebsOptimized,omitempty" tf:"ebs_optimized"`

	// +kubebuilder:validation:Optional
	ElasticGpuSpecifications []ElasticGpuSpecificationsParameters `json:"elasticGpuSpecifications,omitempty" tf:"elastic_gpu_specifications"`

	// +kubebuilder:validation:Optional
	ElasticInferenceAccelerator []ElasticInferenceAcceleratorParameters `json:"elasticInferenceAccelerator,omitempty" tf:"elastic_inference_accelerator"`

	// +kubebuilder:validation:Optional
	EnclaveOptions []EnclaveOptionsParameters `json:"enclaveOptions,omitempty" tf:"enclave_options"`

	// +kubebuilder:validation:Optional
	HibernationOptions []HibernationOptionsParameters `json:"hibernationOptions,omitempty" tf:"hibernation_options"`

	// +kubebuilder:validation:Optional
	IamInstanceProfile []IamInstanceProfileParameters `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile"`

	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id"`

	// +kubebuilder:validation:Optional
	InstanceInitiatedShutdownBehavior *string `json:"instanceInitiatedShutdownBehavior,omitempty" tf:"instance_initiated_shutdown_behavior"`

	// +kubebuilder:validation:Optional
	InstanceMarketOptions []InstanceMarketOptionsParameters `json:"instanceMarketOptions,omitempty" tf:"instance_market_options"`

	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type"`

	// +kubebuilder:validation:Optional
	KernelID *string `json:"kernelId,omitempty" tf:"kernel_id"`

	// +kubebuilder:validation:Optional
	KeyName *string `json:"keyName,omitempty" tf:"key_name"`

	// +kubebuilder:validation:Optional
	LicenseSpecification []LicenseSpecificationParameters `json:"licenseSpecification,omitempty" tf:"license_specification"`

	// +kubebuilder:validation:Optional
	MetadataOptions []LaunchTemplateMetadataOptionsParameters `json:"metadataOptions,omitempty" tf:"metadata_options"`

	// +kubebuilder:validation:Optional
	Monitoring []MonitoringParameters `json:"monitoring,omitempty" tf:"monitoring"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name"`

	// +kubebuilder:validation:Optional
	NamePrefix *string `json:"namePrefix,omitempty" tf:"name_prefix"`

	// +kubebuilder:validation:Optional
	NetworkInterfaces []NetworkInterfacesParameters `json:"networkInterfaces,omitempty" tf:"network_interfaces"`

	// +kubebuilder:validation:Optional
	Placement []PlacementParameters `json:"placement,omitempty" tf:"placement"`

	// +kubebuilder:validation:Optional
	RAMDiskID *string `json:"ramDiskId,omitempty" tf:"ram_disk_id"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	SecurityGroupNames []string `json:"securityGroupNames,omitempty" tf:"security_group_names"`

	// +kubebuilder:validation:Optional
	TagSpecifications []TagSpecificationsParameters `json:"tagSpecifications,omitempty" tf:"tag_specifications"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Optional
	TagsAll map[string]string `json:"tagsAll,omitempty" tf:"tags_all"`

	// +kubebuilder:validation:Optional
	UpdateDefaultVersion *bool `json:"updateDefaultVersion,omitempty" tf:"update_default_version"`

	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data"`

	// +kubebuilder:validation:Optional
	VpcSecurityGroupIds []string `json:"vpcSecurityGroupIds,omitempty" tf:"vpc_security_group_ids"`
}

type LicenseSpecificationObservation struct {
}

type LicenseSpecificationParameters struct {

	// +kubebuilder:validation:Required
	LicenseConfigurationArn string `json:"licenseConfigurationArn" tf:"license_configuration_arn"`
}

type MonitoringObservation struct {
}

type MonitoringParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
}

type NetworkInterfacesObservation struct {
}

type NetworkInterfacesParameters struct {

	// +kubebuilder:validation:Optional
	AssociateCarrierIPAddress *string `json:"associateCarrierIpAddress,omitempty" tf:"associate_carrier_ip_address"`

	// +kubebuilder:validation:Optional
	AssociatePublicIPAddress *string `json:"associatePublicIpAddress,omitempty" tf:"associate_public_ip_address"`

	// +kubebuilder:validation:Optional
	DeleteOnTermination *string `json:"deleteOnTermination,omitempty" tf:"delete_on_termination"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description"`

	// +kubebuilder:validation:Optional
	DeviceIndex *int64 `json:"deviceIndex,omitempty" tf:"device_index"`

	// +kubebuilder:validation:Optional
	IPv4AddressCount *int64 `json:"ipv4AddressCount,omitempty" tf:"ipv4_address_count"`

	// +kubebuilder:validation:Optional
	IPv4Addresses []string `json:"ipv4Addresses,omitempty" tf:"ipv4_addresses"`

	// +kubebuilder:validation:Optional
	IPv6AddressCount *int64 `json:"ipv6AddressCount,omitempty" tf:"ipv6_address_count"`

	// +kubebuilder:validation:Optional
	IPv6Addresses []string `json:"ipv6Addresses,omitempty" tf:"ipv6_addresses"`

	// +kubebuilder:validation:Optional
	InterfaceType *string `json:"interfaceType,omitempty" tf:"interface_type"`

	// +kubebuilder:validation:Optional
	NetworkInterfaceID *string `json:"networkInterfaceId,omitempty" tf:"network_interface_id"`

	// +kubebuilder:validation:Optional
	PrivateIPAddress *string `json:"privateIpAddress,omitempty" tf:"private_ip_address"`

	// +kubebuilder:validation:Optional
	SecurityGroups []string `json:"securityGroups,omitempty" tf:"security_groups"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id"`
}

type PlacementObservation struct {
}

type PlacementParameters struct {

	// +kubebuilder:validation:Optional
	Affinity *string `json:"affinity,omitempty" tf:"affinity"`

	// +kubebuilder:validation:Optional
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone"`

	// +kubebuilder:validation:Optional
	GroupName *string `json:"groupName,omitempty" tf:"group_name"`

	// +kubebuilder:validation:Optional
	HostID *string `json:"hostId,omitempty" tf:"host_id"`

	// +kubebuilder:validation:Optional
	HostResourceGroupArn *string `json:"hostResourceGroupArn,omitempty" tf:"host_resource_group_arn"`

	// +kubebuilder:validation:Optional
	PartitionNumber *int64 `json:"partitionNumber,omitempty" tf:"partition_number"`

	// +kubebuilder:validation:Optional
	SpreadDomain *string `json:"spreadDomain,omitempty" tf:"spread_domain"`

	// +kubebuilder:validation:Optional
	Tenancy *string `json:"tenancy,omitempty" tf:"tenancy"`
}

type SpotOptionsObservation struct {
}

type SpotOptionsParameters struct {

	// +kubebuilder:validation:Optional
	BlockDurationMinutes *int64 `json:"blockDurationMinutes,omitempty" tf:"block_duration_minutes"`

	// +kubebuilder:validation:Optional
	InstanceInterruptionBehavior *string `json:"instanceInterruptionBehavior,omitempty" tf:"instance_interruption_behavior"`

	// +kubebuilder:validation:Optional
	MaxPrice *string `json:"maxPrice,omitempty" tf:"max_price"`

	// +kubebuilder:validation:Optional
	SpotInstanceType *string `json:"spotInstanceType,omitempty" tf:"spot_instance_type"`

	// +kubebuilder:validation:Optional
	ValidUntil *string `json:"validUntil,omitempty" tf:"valid_until"`
}

type TagSpecificationsObservation struct {
}

type TagSpecificationsParameters struct {

	// +kubebuilder:validation:Optional
	ResourceType *string `json:"resourceType,omitempty" tf:"resource_type"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`
}

// LaunchTemplateSpec defines the desired state of LaunchTemplate
type LaunchTemplateSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       LaunchTemplateParameters `json:"forProvider"`
}

// LaunchTemplateStatus defines the observed state of LaunchTemplate.
type LaunchTemplateStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          LaunchTemplateObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// LaunchTemplate is the Schema for the LaunchTemplates API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type LaunchTemplate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LaunchTemplateSpec   `json:"spec"`
	Status            LaunchTemplateStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LaunchTemplateList contains a list of LaunchTemplates
type LaunchTemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LaunchTemplate `json:"items"`
}

// Repository type metadata.
var (
	LaunchTemplateKind             = "LaunchTemplate"
	LaunchTemplateGroupKind        = schema.GroupKind{Group: Group, Kind: LaunchTemplateKind}.String()
	LaunchTemplateKindAPIVersion   = LaunchTemplateKind + "." + GroupVersion.String()
	LaunchTemplateGroupVersionKind = GroupVersion.WithKind(LaunchTemplateKind)
)

func init() {
	SchemeBuilder.Register(&LaunchTemplate{}, &LaunchTemplateList{})
}
