/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type BrokerLogsObservation struct {
}

type BrokerLogsParameters struct {

	// +kubebuilder:validation:Optional
	CloudwatchLogs []CloudwatchLogsParameters `json:"cloudwatchLogs,omitempty" tf:"cloudwatch_logs"`

	// +kubebuilder:validation:Optional
	Firehose []FirehoseParameters `json:"firehose,omitempty" tf:"firehose"`

	// +kubebuilder:validation:Optional
	S3 []S3Parameters `json:"s3,omitempty" tf:"s3"`
}

type BrokerNodeGroupInfoObservation struct {
}

type BrokerNodeGroupInfoParameters struct {

	// +kubebuilder:validation:Optional
	AzDistribution *string `json:"azDistribution,omitempty" tf:"az_distribution"`

	// +kubebuilder:validation:Required
	ClientSubnets []string `json:"clientSubnets" tf:"client_subnets"`

	// +kubebuilder:validation:Required
	EbsVolumeSize int64 `json:"ebsVolumeSize" tf:"ebs_volume_size"`

	// +kubebuilder:validation:Required
	InstanceType string `json:"instanceType" tf:"instance_type"`

	// +kubebuilder:validation:Required
	SecurityGroups []string `json:"securityGroups" tf:"security_groups"`
}

type ClientAuthenticationObservation struct {
}

type ClientAuthenticationParameters struct {

	// +kubebuilder:validation:Optional
	Sasl []SaslParameters `json:"sasl,omitempty" tf:"sasl"`

	// +kubebuilder:validation:Optional
	TLS []TLSParameters `json:"tls,omitempty" tf:"tls"`
}

type CloudwatchLogsObservation struct {
}

type CloudwatchLogsParameters struct {

	// +kubebuilder:validation:Required
	Enabled bool `json:"enabled" tf:"enabled"`

	// +kubebuilder:validation:Optional
	LogGroup *string `json:"logGroup,omitempty" tf:"log_group"`
}

type ConfigurationInfoObservation struct {
}

type ConfigurationInfoParameters struct {

	// +kubebuilder:validation:Required
	Arn string `json:"arn" tf:"arn"`

	// +kubebuilder:validation:Required
	Revision int64 `json:"revision" tf:"revision"`
}

type EncryptionInTransitObservation struct {
}

type EncryptionInTransitParameters struct {

	// +kubebuilder:validation:Optional
	ClientBroker *string `json:"clientBroker,omitempty" tf:"client_broker"`

	// +kubebuilder:validation:Optional
	InCluster *bool `json:"inCluster,omitempty" tf:"in_cluster"`
}

type EncryptionInfoObservation struct {
}

type EncryptionInfoParameters struct {

	// +kubebuilder:validation:Optional
	EncryptionAtRestKmsKeyArn *string `json:"encryptionAtRestKmsKeyArn,omitempty" tf:"encryption_at_rest_kms_key_arn"`

	// +kubebuilder:validation:Optional
	EncryptionInTransit []EncryptionInTransitParameters `json:"encryptionInTransit,omitempty" tf:"encryption_in_transit"`
}

type FirehoseObservation struct {
}

type FirehoseParameters struct {

	// +kubebuilder:validation:Optional
	DeliveryStream *string `json:"deliveryStream,omitempty" tf:"delivery_stream"`

	// +kubebuilder:validation:Required
	Enabled bool `json:"enabled" tf:"enabled"`
}

type JmxExporterObservation struct {
}

type JmxExporterParameters struct {

	// +kubebuilder:validation:Required
	EnabledInBroker bool `json:"enabledInBroker" tf:"enabled_in_broker"`
}

type LoggingInfoObservation struct {
}

type LoggingInfoParameters struct {

	// +kubebuilder:validation:Required
	BrokerLogs []BrokerLogsParameters `json:"brokerLogs" tf:"broker_logs"`
}

type MskClusterObservation struct {
	Arn string `json:"arn" tf:"arn"`

	BootstrapBrokers string `json:"bootstrapBrokers" tf:"bootstrap_brokers"`

	BootstrapBrokersSaslIam string `json:"bootstrapBrokersSaslIam" tf:"bootstrap_brokers_sasl_iam"`

	BootstrapBrokersSaslScram string `json:"bootstrapBrokersSaslScram" tf:"bootstrap_brokers_sasl_scram"`

	BootstrapBrokersTLS string `json:"bootstrapBrokersTls" tf:"bootstrap_brokers_tls"`

	CurrentVersion string `json:"currentVersion" tf:"current_version"`

	ZookeeperConnectString string `json:"zookeeperConnectString" tf:"zookeeper_connect_string"`
}

type MskClusterParameters struct {

	// +kubebuilder:validation:Required
	BrokerNodeGroupInfo []BrokerNodeGroupInfoParameters `json:"brokerNodeGroupInfo" tf:"broker_node_group_info"`

	// +kubebuilder:validation:Optional
	ClientAuthentication []ClientAuthenticationParameters `json:"clientAuthentication,omitempty" tf:"client_authentication"`

	// +kubebuilder:validation:Required
	ClusterName string `json:"clusterName" tf:"cluster_name"`

	// +kubebuilder:validation:Optional
	ConfigurationInfo []ConfigurationInfoParameters `json:"configurationInfo,omitempty" tf:"configuration_info"`

	// +kubebuilder:validation:Optional
	EncryptionInfo []EncryptionInfoParameters `json:"encryptionInfo,omitempty" tf:"encryption_info"`

	// +kubebuilder:validation:Optional
	EnhancedMonitoring *string `json:"enhancedMonitoring,omitempty" tf:"enhanced_monitoring"`

	// +kubebuilder:validation:Required
	KafkaVersion string `json:"kafkaVersion" tf:"kafka_version"`

	// +kubebuilder:validation:Optional
	LoggingInfo []LoggingInfoParameters `json:"loggingInfo,omitempty" tf:"logging_info"`

	// +kubebuilder:validation:Required
	NumberOfBrokerNodes int64 `json:"numberOfBrokerNodes" tf:"number_of_broker_nodes"`

	// +kubebuilder:validation:Optional
	OpenMonitoring []OpenMonitoringParameters `json:"openMonitoring,omitempty" tf:"open_monitoring"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Optional
	TagsAll map[string]string `json:"tagsAll,omitempty" tf:"tags_all"`
}

type NodeExporterObservation struct {
}

type NodeExporterParameters struct {

	// +kubebuilder:validation:Required
	EnabledInBroker bool `json:"enabledInBroker" tf:"enabled_in_broker"`
}

type OpenMonitoringObservation struct {
}

type OpenMonitoringParameters struct {

	// +kubebuilder:validation:Required
	Prometheus []PrometheusParameters `json:"prometheus" tf:"prometheus"`
}

type PrometheusObservation struct {
}

type PrometheusParameters struct {

	// +kubebuilder:validation:Optional
	JmxExporter []JmxExporterParameters `json:"jmxExporter,omitempty" tf:"jmx_exporter"`

	// +kubebuilder:validation:Optional
	NodeExporter []NodeExporterParameters `json:"nodeExporter,omitempty" tf:"node_exporter"`
}

type S3Observation struct {
}

type S3Parameters struct {

	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket,omitempty" tf:"bucket"`

	// +kubebuilder:validation:Required
	Enabled bool `json:"enabled" tf:"enabled"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix"`
}

type SaslObservation struct {
}

type SaslParameters struct {

	// +kubebuilder:validation:Optional
	Iam *bool `json:"iam,omitempty" tf:"iam"`

	// +kubebuilder:validation:Optional
	Scram *bool `json:"scram,omitempty" tf:"scram"`
}

type TLSObservation struct {
}

type TLSParameters struct {

	// +kubebuilder:validation:Optional
	CertificateAuthorityArns []string `json:"certificateAuthorityArns,omitempty" tf:"certificate_authority_arns"`
}

// MskClusterSpec defines the desired state of MskCluster
type MskClusterSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       MskClusterParameters `json:"forProvider"`
}

// MskClusterStatus defines the observed state of MskCluster.
type MskClusterStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          MskClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MskCluster is the Schema for the MskClusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type MskCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MskClusterSpec   `json:"spec"`
	Status            MskClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MskClusterList contains a list of MskClusters
type MskClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MskCluster `json:"items"`
}

// Repository type metadata.
var (
	MskClusterKind             = "MskCluster"
	MskClusterGroupKind        = schema.GroupKind{Group: Group, Kind: MskClusterKind}.String()
	MskClusterKindAPIVersion   = MskClusterKind + "." + GroupVersion.String()
	MskClusterGroupVersionKind = GroupVersion.WithKind(MskClusterKind)
)

func init() {
	SchemeBuilder.Register(&MskCluster{}, &MskClusterList{})
}
